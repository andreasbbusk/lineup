/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export interface paths {
    "/users/{username}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get user profile
         * @description Get user profile by username
         *
         *     Retrieves a user's profile information. Returns public profile data by default.
         *     If authenticated and viewing your own profile, returns additional private fields
         *     such as phone number, year of birth, etc.
         *
         *     Authentication is optional - endpoint can be accessed without a token for public profiles.
         */
        get: operations["GetUser"];
        /**
         * Update user profile
         * @description Update own profile
         *
         *     Updates the authenticated user's profile information. Only the profile owner
         *     can update their own profile. All fields in the request body are optional -
         *     only provided fields will be updated.
         */
        put: operations["UpdateProfile"];
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
<<<<<<< HEAD
    "/users/{username}/social-media": {
=======
    "/upload/signed-url": {
>>>>>>> dev
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
<<<<<<< HEAD
        /**
         * Get user social media
         * @description Get user's social media links
         *
         *     Returns all social media platform links for the specified user.
         *     This endpoint is public and does not require authentication.
         */
        get: operations["GetUserSocialMedia"];
        /**
         * Update user social media
         * @description Update user's social media links
         *
         *     Updates the authenticated user's social media links.
         *     Only the profile owner can update their own social media.
         */
        put: operations["UpdateUserSocialMedia"];
        post?: never;
=======
        get?: never;
        put?: never;
        /**
         * Generate signed upload URL
         * @description Generate a signed upload URL for direct client uploads
         *
         *     Returns a temporary signed URL that allows clients to upload files directly
         *     to Supabase Storage, bypassing the backend. This improves scalability by
         *     avoiding large file buffers in the Node.js server.
         *
         *     The client should:
         *     1. Call this endpoint to get a signed URL
         *     2. Upload the file directly to the signed URL using fetch/PUT
         *     3. Use the returned filePath to construct the public URL
         *     4. Include the public URL when creating posts or updating avatars
         *
         *     - **Images**: JPEG, PNG, GIF, WebP
         *     - **Videos**: MP4, WebM, QuickTime
         *     - **Upload Types**: "post" (default) for post media, "avatar" for profile pictures
         */
        post: operations["GenerateSignedUploadUrl"];
>>>>>>> dev
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
<<<<<<< HEAD
    "/users/{username}/faq": {
=======
    "/media/{mediaId}": {
>>>>>>> dev
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
<<<<<<< HEAD
        /**
         * Get user FAQ
         * @description Get user's FAQ answers
         *
         *     Returns all FAQ answers for the specified user with their corresponding questions.
         *     This endpoint is public and does not require authentication.
         */
        get: operations["GetUserFaq"];
        put?: never;
        /**
         * Upsert user FAQ answer
         * @description Create or update user's FAQ answer
         *
         *     Adds or updates an answer to an FAQ question for the authenticated user.
         *     Only the profile owner can manage their own FAQ.
         */
        post: operations["UpsertUserFaq"];
        delete?: never;
=======
        get?: never;
        put?: never;
        post?: never;
        /**
         * Delete media
         * @description Delete a media file
         *
         *     Removes the file from Supabase Storage and deletes the media record from the database.
         *     Only authenticated users can delete media.
         */
        delete: operations["DeleteMedia"];
>>>>>>> dev
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
<<<<<<< HEAD
    "/users/{username}/faq/{questionId}": {
=======
    "/search": {
>>>>>>> dev
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
<<<<<<< HEAD
        get?: never;
        put?: never;
        post?: never;
        /**
         * Delete user FAQ answer
         * @description Delete user's FAQ answer
         *
         *     Removes an answer to an FAQ question for the authenticated user.
         *     Only the profile owner can delete their own FAQ answers.
         */
        delete: operations["DeleteUserFaq"];
=======
        /**
         * Search across users, posts, and tags
         * @description Search for users, posts, or tags
         *
         *     Performs a search across different entity types based on the specified tab.
         *     Returns polymorphic results that vary by tab type.
         *
         *     - **for_you**: Personalized results combining people and collaboration requests
         *     - **people**: Search for users with filters (location, genres, looking for)
         *     - **collaborations**: Search for collaboration request posts
         *     - **tags**: Search for metadata (tags, genres, artists)
         */
        get: operations["Search"];
        put?: never;
        post?: never;
        delete?: never;
>>>>>>> dev
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
<<<<<<< HEAD
    "/users/{username}/looking-for": {
=======
    "/users/{username}/reviews": {
>>>>>>> dev
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
<<<<<<< HEAD
         * Get user looking for preferences
         * @description Get what user is looking for
         *
         *     Returns the user's "looking for" preferences (connect, promote, find-band, find-services).
         *     This endpoint is public and does not require authentication.
         */
        get: operations["GetUserLookingFor"];
        put?: never;
        post?: never;
=======
         * Get user reviews
         * @description Get all reviews for a user
         *
         *     Returns all reviews for a specific user with reviewer information.
         *     This endpoint is public and does not require authentication.
         */
        get: operations["GetUserReviews"];
        put?: never;
        /**
         * Create a review
         * @description Create a review for a user
         *
         *     Allows the authenticated user to write a review for another user.
         *     Prevents self-reviews and duplicate reviews.
         */
        post: operations["CreateReview"];
>>>>>>> dev
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
<<<<<<< HEAD
    "/faq-questions": {
=======
    "/reviews/{reviewId}": {
>>>>>>> dev
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
<<<<<<< HEAD
         * Get all FAQ questions
         * @description Get all available FAQ questions
         *
         *     Returns all active FAQ questions that users can answer on their profiles.
         *     This endpoint is public and does not require authentication.
         */
        get: operations["GetAllFaqQuestions"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/upload": {
=======
         * Get review by ID
         * @description Get a review by ID
         *
         *     Returns a specific review with reviewer information.
         *     This endpoint is public and does not require authentication.
         */
        get: operations["GetReview"];
        put?: never;
        post?: never;
        /**
         * Delete a review
         * @description Delete a review
         *
         *     Permanently deletes a review.
         *     Only the reviewer can delete their own review.
         */
        delete: operations["DeleteReview"];
        options?: never;
        head?: never;
        /**
         * Update a review
         * @description Update a review
         *
         *     Updates the rating and/or description of a review.
         *     Only the reviewer can update their own review.
         */
        patch: operations["UpdateReview"];
        trace?: never;
    };
    "/posts": {
>>>>>>> dev
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
<<<<<<< HEAD
        get?: never;
        put?: never;
        /**
         * Upload files
         * @description Upload files (images or videos) for posts or avatars
         *
         *     Supports batch upload of up to 4 files.
         *     Files are uploaded to Supabase Storage and media records are created in the database.
         *
         *     - **Images**: JPEG, PNG, GIF, WebP (max 50MB each)
         *     - **Videos**: MP4, WebM, QuickTime (max 50MB each)
         *     - **Thumbnails**: Can be generated for videos if requested
         */
        post: operations["UploadFiles"];
=======
        /**
         * List posts
         * @description List posts with filters and pagination
         *
         *     Returns a paginated list of posts with optional filters.
         *     Supports filtering by type, author, location, genres, tags, and paid opportunities.
         *     Can optionally include engagement data (requires authentication).
         *
         *     Posts are public and can be viewed without authentication, but engagement data
         *     (likes, comments, bookmarks) requires authentication.
         */
        get: operations["ListPosts"];
        put?: never;
        /**
         * Create a post
         * @description Create a new post
         *
         *     Creates a new post (note, request, or story) with optional metadata, media,
         *     and tagged users. The post is automatically associated with the authenticated user.
         *
         *     For "note" type posts, you can include tags.
         *     For "request" type posts, you can include genres and paid_opportunity flag.
         *     All post types can include media and tagged users.
         */
        post: operations["CreatePost"];
>>>>>>> dev
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
<<<<<<< HEAD
    "/media/{mediaId}": {
=======
    "/posts/{id}": {
>>>>>>> dev
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
<<<<<<< HEAD
        get?: never;
        put?: never;
        post?: never;
        /**
         * Delete media
         * @description Delete a media file
         *
         *     Removes the file from Supabase Storage and deletes the media record from the database.
         *     Only authenticated users can delete media.
         */
        delete: operations["DeleteMedia"];
=======
        /**
         * Get post by ID
         * @description Get a single post by ID
         *
         *     Returns a single post with full details including author, metadata, media, and tagged users.
         *     Can optionally include comments and engagement data (requires authentication).
         *
         *     Posts are public and can be viewed without authentication, but engagement data
         *     (likes, comments, bookmarks) requires authentication.
         */
        get: operations["GetPost"];
        put?: never;
        post?: never;
        delete?: never;
>>>>>>> dev
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
<<<<<<< HEAD
    "/search": {
=======
    "/notifications": {
>>>>>>> dev
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
<<<<<<< HEAD
         * Search across users, posts, and tags
         * @description Search for users, posts, or tags
         *
         *     Performs a search across different entity types based on the specified tab.
         *     Returns polymorphic results that vary by tab type.
         *
         *     - **for_you**: Personalized results combining people and collaboration requests
         *     - **people**: Search for users with filters (location, genres, looking for)
         *     - **collaborations**: Search for collaboration request posts
         *     - **tags**: Search for metadata (tags, genres, artists)
         */
        get: operations["Search"];
=======
         * Get user notifications
         * @description Get notifications for the authenticated user
         *
         *     Returns notifications for the authenticated user with optional filters.
         *     Supports filtering by type and unread status, with cursor-based pagination.
         *     Archived notifications are excluded by default.
         */
        get: operations["GetNotifications"];
>>>>>>> dev
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
<<<<<<< HEAD
    "/users/{username}/reviews": {
=======
    "/notifications/{notificationId}": {
>>>>>>> dev
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
<<<<<<< HEAD
         * Get user reviews
         * @description Get all reviews for a user
         *
         *     Returns all reviews for a specific user with reviewer information.
         *     This endpoint is public and does not require authentication.
         */
        get: operations["GetUserReviews"];
        put?: never;
        /**
         * Create a review
         * @description Create a review for a user
         *
         *     Allows the authenticated user to write a review for another user.
         *     Prevents self-reviews and duplicate reviews.
         */
        post: operations["CreateReview"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/reviews/{reviewId}": {
=======
         * Get notification by ID
         * @description Get a notification by ID
         *
         *     Returns a specific notification with actor information.
         *     Only the recipient can access their own notifications.
         */
        get: operations["GetNotification"];
        put?: never;
        post?: never;
        /**
         * Delete a notification
         * @description Delete a notification
         *
         *     Permanently deletes a notification.
         *     Only the recipient can delete their own notifications.
         */
        delete: operations["DeleteNotification"];
        options?: never;
        head?: never;
        /**
         * Mark notification as read/unread
         * @description Update a notification
         *
         *     Marks a notification as read or unread.
         *     Only the recipient can update their own notifications.
         */
        patch: operations["UpdateNotification"];
        trace?: never;
    };
    "/metadata": {
>>>>>>> dev
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
<<<<<<< HEAD
         * Get review by ID
         * @description Get a review by ID
         *
         *     Returns a specific review with reviewer information.
         *     This endpoint is public and does not require authentication.
         */
        get: operations["GetReview"];
        put?: never;
        post?: never;
        /**
         * Delete a review
         * @description Delete a review
         *
         *     Permanently deletes a review.
         *     Only the reviewer can delete their own review.
         */
        delete: operations["DeleteReview"];
        options?: never;
        head?: never;
        /**
         * Update a review
         * @description Update a review
         *
         *     Updates the rating and/or description of a review.
         *     Only the reviewer can update their own review.
         */
        patch: operations["UpdateReview"];
        trace?: never;
    };
    "/posts": {
=======
         * Get all metadata
         * @description Get all metadata
         *
         *     Returns all tags, genres, and artists grouped by type.
         *     Used for dropdowns, autocomplete, and tag/genre selectors.
         *     This endpoint is public and does not require authentication.
         */
        get: operations["GetMetadata"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/messages/{conversationId}": {
>>>>>>> dev
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
<<<<<<< HEAD
        get?: never;
        put?: never;
        /**
         * Create a post
         * @description Create a new post
         *
         *     Creates a new post (note, request, or story) with optional metadata, media,
         *     and tagged users. The post is automatically associated with the authenticated user.
         *
         *     For "note" type posts, you can include tags.
         *     For "request" type posts, you can include genres and paid_opportunity flag.
         *     All post types can include media and tagged users.
         */
        post: operations["CreatePost"];
=======
        get: operations["GetMessages"];
        put?: never;
        post?: never;
>>>>>>> dev
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
<<<<<<< HEAD
    "/notifications": {
=======
    "/messages": {
>>>>>>> dev
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
<<<<<<< HEAD
        /**
         * Get user notifications
         * @description Get notifications for the authenticated user
         *
         *     Returns notifications for the authenticated user with optional filters.
         *     Supports filtering by type and unread status, with cursor-based pagination.
         *     Archived notifications are excluded by default.
         */
        get: operations["GetNotifications"];
        put?: never;
        post?: never;
=======
        get?: never;
        put?: never;
        post: operations["SendMessage"];
>>>>>>> dev
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
<<<<<<< HEAD
    "/notifications/{notificationId}": {
=======
    "/messages/{messageId}": {
>>>>>>> dev
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
<<<<<<< HEAD
        /**
         * Get notification by ID
         * @description Get a notification by ID
         *
         *     Returns a specific notification with actor information.
         *     Only the recipient can access their own notifications.
         */
        get: operations["GetNotification"];
        put?: never;
        post?: never;
        /**
         * Delete a notification
         * @description Delete a notification
         *
         *     Permanently deletes a notification.
         *     Only the recipient can delete their own notifications.
         */
        delete: operations["DeleteNotification"];
        options?: never;
        head?: never;
        /**
         * Mark notification as read/unread
         * @description Update a notification
         *
         *     Marks a notification as read or unread.
         *     Only the recipient can update their own notifications.
         */
        patch: operations["UpdateNotification"];
        trace?: never;
    };
    "/metadata": {
=======
        get?: never;
        put: operations["EditMessage"];
        post?: never;
        delete: operations["DeleteMessage"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/messages/read": {
>>>>>>> dev
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
<<<<<<< HEAD
        /**
         * Get all metadata
         * @description Get all metadata
         *
         *     Returns all tags, genres, and artists grouped by type.
         *     Used for dropdowns, autocomplete, and tag/genre selectors.
         *     This endpoint is public and does not require authentication.
         */
        get: operations["GetMetadata"];
        put?: never;
        post?: never;
=======
        get?: never;
        put?: never;
        post: operations["MarkAsRead"];
>>>>>>> dev
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
<<<<<<< HEAD
    "/messages/{conversationId}": {
=======
    "/messages/typing/{conversationId}": {
>>>>>>> dev
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
<<<<<<< HEAD
        get: operations["GetMessages"];
        put?: never;
        post?: never;
=======
        get?: never;
        put?: never;
        post: operations["SetTyping"];
>>>>>>> dev
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
<<<<<<< HEAD
    "/messages": {
=======
    "/feed": {
>>>>>>> dev
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
<<<<<<< HEAD
        get?: never;
        put?: never;
        post: operations["SendMessage"];
=======
        /**
         * Get home feed
         * @description Get home feed
         *
         *     Returns feed content based on the specified component:
         *     - "posts": Posts from users you follow (with pagination)
         *     - "recommendations": Collaboration request recommendations
         *     - "stories": Stories from followed users (coming soon)
         *
         *     Posts feed includes engagement data (likes, comments, bookmarks counts)
         *     and user interaction state (hasLiked, hasBookmarked).
         */
        get: operations["GetFeed"];
        put?: never;
        post?: never;
>>>>>>> dev
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
<<<<<<< HEAD
    "/messages/{messageId}": {
=======
    "/conversations": {
>>>>>>> dev
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
<<<<<<< HEAD
        get?: never;
        put: operations["EditMessage"];
        post?: never;
        delete: operations["DeleteMessage"];
=======
        get: operations["GetConversations"];
        put?: never;
        post: operations["CreateConversation"];
        delete?: never;
>>>>>>> dev
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
<<<<<<< HEAD
    "/messages/read": {
=======
    "/conversations/unread-count": {
>>>>>>> dev
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
<<<<<<< HEAD
        get?: never;
        put?: never;
        post: operations["MarkAsRead"];
=======
        get: operations["GetUnreadCount"];
        put?: never;
        post?: never;
>>>>>>> dev
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
<<<<<<< HEAD
    "/messages/typing/{conversationId}": {
=======
    "/conversations/{conversationId}": {
>>>>>>> dev
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
<<<<<<< HEAD
        get?: never;
        put?: never;
        post: operations["SetTyping"];
        delete?: never;
=======
        get: operations["GetConversation"];
        put: operations["UpdateConversation"];
        post?: never;
        delete: operations["DeleteConversation"];
>>>>>>> dev
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
<<<<<<< HEAD
    "/feed": {
=======
    "/connections": {
>>>>>>> dev
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
<<<<<<< HEAD
         * Get home feed
         * @description Get home feed
         *
         *     Returns feed content based on the specified component:
         *     - "posts": Posts from users you follow (with pagination)
         *     - "recommendations": Collaboration request recommendations
         *     - "stories": Stories from followed users (coming soon)
         *
         *     Posts feed includes engagement data (likes, comments, bookmarks counts)
         *     and user interaction state (hasLiked, hasBookmarked).
         */
        get: operations["GetFeed"];
        put?: never;
        post?: never;
=======
         * Get user's connection requests
         * @description Get all connection requests for the authenticated user
         *
         *     Returns both sent and received connection requests for the authenticated user.
         *     Each request includes requester and recipient profile information.
         */
        get: operations["GetConnectionRequests"];
        put?: never;
        /**
         * Send a connection request
         * @description Create a connection request
         *
         *     Allows the authenticated user to send a connection request to another user.
         *     The recipient must exist and there must not be an existing connection request.
         */
        post: operations["CreateConnectionRequest"];
>>>>>>> dev
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
<<<<<<< HEAD
    "/conversations": {
=======
    "/connections/sent/{userId}": {
>>>>>>> dev
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
<<<<<<< HEAD
        get: operations["GetConversations"];
        put?: never;
        post: operations["CreateConversation"];
=======
        /**
         * Get sent connection requests by user
         * @description Get connection requests sent by a user
         *
         *     Returns all connection requests sent by the specified user.
         *     This endpoint can be accessed without authentication.
         */
        get: operations["GetSentConnectionRequests"];
        put?: never;
        post?: never;
>>>>>>> dev
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
<<<<<<< HEAD
    "/conversations/unread-count": {
=======
    "/connections/received/{userId}": {
>>>>>>> dev
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
<<<<<<< HEAD
        get: operations["GetUnreadCount"];
=======
        /**
         * Get received connection requests by user
         * @description Get connection requests received by a user
         *
         *     Returns all connection requests received by the specified user.
         *     This endpoint can be accessed without authentication.
         */
        get: operations["GetReceivedConnectionRequests"];
>>>>>>> dev
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
<<<<<<< HEAD
    "/conversations/{conversationId}": {
=======
    "/connections/status/{targetUserId}": {
>>>>>>> dev
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
<<<<<<< HEAD
        get: operations["GetConversation"];
        put: operations["UpdateConversation"];
        post?: never;
        delete: operations["DeleteConversation"];
=======
        /**
         * Get connection status between two users
         * @description Get connection status between the authenticated user and another user
         *
         *     Returns the connection if it exists (pending, accepted), null otherwise.
         *     Rejected connections are not returned.
         */
        get: operations["GetConnectionStatus"];
        put?: never;
        post?: never;
        delete?: never;
>>>>>>> dev
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
<<<<<<< HEAD
    "/connections": {
=======
    "/connections/accepted/{userId}": {
>>>>>>> dev
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
<<<<<<< HEAD
         * Get user's connection requests
         * @description Get all connection requests for the authenticated user
         *
         *     Returns both sent and received connection requests for the authenticated user.
         *     Each request includes requester and recipient profile information.
         */
        get: operations["GetConnectionRequests"];
        put?: never;
        /**
         * Send a connection request
         * @description Create a connection request
         *
         *     Allows the authenticated user to send a connection request to another user.
         *     The recipient must exist and there must not be an existing connection request.
         */
        post: operations["CreateConnectionRequest"];
=======
         * Get accepted connections by user
         * @description Get accepted connections for a specific user
         *
         *     Returns only accepted connections for the specified user.
         *     This endpoint can be accessed without authentication.
         */
        get: operations["GetUserAcceptedConnections"];
        put?: never;
        post?: never;
>>>>>>> dev
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
<<<<<<< HEAD
    "/connections/sent/{userId}": {
=======
    "/connections/{requestId}": {
>>>>>>> dev
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
<<<<<<< HEAD
        /**
         * Get sent connection requests by user
         * @description Get connection requests sent by a user
         *
         *     Returns all connection requests sent by the specified user.
         *     This endpoint can be accessed without authentication.
         */
        get: operations["GetSentConnectionRequests"];
        put?: never;
        post?: never;
        delete?: never;
=======
        get?: never;
        /**
         * Accept or reject a connection request
         * @description Update a connection request status
         *
         *     Allows the recipient to accept or reject a connection request.
         *     Only the recipient can update the status, and only pending requests can be updated.
         */
        put: operations["UpdateConnectionRequest"];
        post?: never;
        /**
         * Delete a connection request
         * @description Delete a connection request
         *
         *     Removes a connection request. Only the requester can delete a pending request.
         */
        delete: operations["DeleteConnectionRequest"];
>>>>>>> dev
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
<<<<<<< HEAD
    "/connections/received/{userId}": {
=======
    "/comments/post/{postId}": {
>>>>>>> dev
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
<<<<<<< HEAD
         * Get received connection requests by user
         * @description Get connection requests received by a user
         *
         *     Returns all connection requests received by the specified user.
         *     This endpoint can be accessed without authentication.
         */
        get: operations["GetReceivedConnectionRequests"];
=======
         * Get comments for a post
         * @description Get all comments for a post
         *
         *     Returns all comments on a specific post, ordered by creation date (oldest first).
         *     Each comment includes the author's profile information.
         */
        get: operations["GetPostComments"];
>>>>>>> dev
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
<<<<<<< HEAD
    "/connections/{requestId}": {
=======
    "/comments/user/{userId}": {
>>>>>>> dev
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
<<<<<<< HEAD
        get?: never;
        /**
         * Accept or reject a connection request
         * @description Update a connection request status
         *
         *     Allows the recipient to accept or reject a connection request.
         *     Only the recipient can update the status, and only pending requests can be updated.
         */
        put: operations["UpdateConnectionRequest"];
        post?: never;
        /**
         * Delete a connection request
         * @description Delete a connection request
         *
         *     Removes a connection request. Only the requester can delete a pending request.
         */
        delete: operations["DeleteConnectionRequest"];
=======
        /**
         * Get comments by user
         * @description Get all comments by a user
         *
         *     Returns all comments created by a specific user, ordered by creation date (newest first).
         *     Each comment includes the author's profile information.
         */
        get: operations["GetUserComments"];
        put?: never;
        post?: never;
        delete?: never;
>>>>>>> dev
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
<<<<<<< HEAD
    "/comments/post/{postId}": {
=======
    "/comments": {
>>>>>>> dev
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
<<<<<<< HEAD
        /**
         * Get comments for a post
         * @description Get all comments for a post
         *
         *     Returns all comments on a specific post, ordered by creation date (oldest first).
         *     Each comment includes the author's profile information.
         */
        get: operations["GetPostComments"];
        put?: never;
        post?: never;
=======
        get?: never;
        put?: never;
        /**
         * Create a comment
         * @description Create a comment on a post
         *
         *     Allows the authenticated user to create a comment on a post.
         *     The post must exist and the comment content must be between 1 and 1000 characters.
         */
        post: operations["CreateComment"];
>>>>>>> dev
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
<<<<<<< HEAD
    "/comments/user/{userId}": {
=======
    "/comments/{commentId}": {
>>>>>>> dev
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
<<<<<<< HEAD
        /**
         * Get comments by user
         * @description Get all comments by a user
         *
         *     Returns all comments created by a specific user, ordered by creation date (newest first).
         *     Each comment includes the author's profile information.
         */
        get: operations["GetUserComments"];
        put?: never;
        post?: never;
        delete?: never;
=======
        get?: never;
        /**
         * Update a comment
         * @description Update a comment
         *
         *     Allows the authenticated user to update their own comment.
         *     Only the comment author can update their comment.
         */
        put: operations["UpdateComment"];
        post?: never;
        /**
         * Delete a comment
         * @description Delete a comment
         *
         *     Removes a comment. Only the comment author can delete their own comment.
         */
        delete: operations["DeleteComment"];
>>>>>>> dev
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
<<<<<<< HEAD
    "/comments": {
=======
    "/collaborations": {
>>>>>>> dev
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
<<<<<<< HEAD
        get?: never;
        put?: never;
        /**
         * Create a comment
         * @description Create a comment on a post
         *
         *     Allows the authenticated user to create a comment on a post.
         *     The post must exist and the comment content must be between 1 and 1000 characters.
         */
        post: operations["CreateComment"];
=======
        /**
         * Get user's collaborations
         * @description Get all collaborations for the authenticated user
         *
         *     Returns a list of all collaborations where the authenticated user is involved.
         *     Each collaboration includes the collaborator's profile information.
         */
        get: operations["GetCollaborations"];
        put?: never;
        /**
         * Create a collaboration
         * @description Create a collaboration
         *
         *     Allows the authenticated user to record a past collaboration with another user.
         *     The collaborator must exist and the collaboration must not already exist.
         */
        post: operations["CreateCollaboration"];
>>>>>>> dev
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
<<<<<<< HEAD
    "/comments/{commentId}": {
=======
    "/collaborations/{userId}": {
>>>>>>> dev
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
<<<<<<< HEAD
        get?: never;
        /**
         * Update a comment
         * @description Update a comment
         *
         *     Allows the authenticated user to update their own comment.
         *     Only the comment author can update their comment.
         */
        put: operations["UpdateComment"];
        post?: never;
        /**
         * Delete a comment
         * @description Delete a comment
         *
         *     Removes a comment. Only the comment author can delete their own comment.
         */
        delete: operations["DeleteComment"];
=======
        /**
         * Get collaborations by user ID
         * @description Get collaborations for a specific user
         *
         *     Returns all collaborations for the specified user. This endpoint can be
         *     accessed without authentication to view public collaboration information.
         */
        get: operations["GetUserCollaborations"];
        put?: never;
        post?: never;
        delete?: never;
>>>>>>> dev
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
<<<<<<< HEAD
    "/collaborations": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get user's collaborations
         * @description Get all collaborations for the authenticated user
         *
         *     Returns a list of all collaborations where the authenticated user is involved.
         *     Each collaboration includes the collaborator's profile information.
         */
        get: operations["GetCollaborations"];
        put?: never;
        /**
         * Create a collaboration
         * @description Create a collaboration
         *
         *     Allows the authenticated user to record a past collaboration with another user.
         *     The collaborator must exist and the collaboration must not already exist.
         */
        post: operations["CreateCollaboration"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/collaborations/{userId}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get collaborations by user ID
         * @description Get collaborations for a specific user
         *
         *     Returns all collaborations for the specified user. This endpoint can be
         *     accessed without authentication to view public collaboration information.
         */
        get: operations["GetUserCollaborations"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
=======
>>>>>>> dev
    "/collaborations/{collaborationId}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post?: never;
        /**
         * Delete a collaboration
         * @description Delete a collaboration
         *
         *     Removes a collaboration. Only the user who created the collaboration
         *     can delete it.
         */
        delete: operations["DeleteCollaboration"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/bookmarks": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get user's bookmarks
         * @description Get all bookmarks for the authenticated user
         *
         *     Returns a list of all bookmarks created by the authenticated user.
         *     Each bookmark includes the post details and author information.
         */
        get: operations["GetBookmarks"];
        put?: never;
        /**
         * Create a bookmark
         * @description Create a bookmark for a post
         *
         *     Allows the authenticated user to bookmark a post for later reference.
         *     The post must exist and must not already be bookmarked by the user.
         */
        post: operations["CreateBookmark"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/bookmarks/{postId}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post?: never;
        /**
         * Delete a bookmark
         * @description Remove a bookmark
         *
         *     Deletes a bookmark for a specific post. Only the user who created
         *     the bookmark can remove it.
         */
        delete: operations["DeleteBookmark"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/auth/check-username": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Check username availability
         * @description Check if a username is available
         *
         *     Returns availability status for real-time validation during registration.
         *     Username must be between 3-30 characters to be considered valid.
         */
        get: operations["CheckUsername"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
}
export type webhooks = Record<string, never>;
export interface components {
    schemas: {
        /**
         * @description API response format for user profile
         * @example {
         *       "id": "123e4567-e89b-12d3-a456-426614174000",
         *       "username": "johndoe",
         *       "firstName": "John",
         *       "lastName": "Doe",
         *       "avatarUrl": "https://example.com/avatar.jpg",
         *       "bio": "Musician and producer",
         *       "location": "New York, NY",
         *       "userType": "musician",
         *       "onboardingCompleted": true,
         *       "createdAt": "2024-01-15T10:30:00Z"
         *     }
         */
        UserProfile: {
            id: string;
            username: string;
            firstName: string;
            lastName: string;
            avatarUrl: string | null;
            bio: string | null;
            aboutMe: string | null;
            /** Format: double */
            phoneCountryCode?: number;
            /** Format: double */
            phoneNumber?: number;
            /** Format: double */
            yearOfBirth?: number;
            location: string;
            userType: string;
            themeColor: string | null;
            spotifyPlaylistUrl: string | null;
            onboardingCompleted: boolean | null;
            createdAt: string | null;
            updatedAt: string | null;
        };
        /** @enum {string} */
        LookingForType: "connect" | "promote" | "find-band" | "find-services";
        /**
         * @description DTO for updating user profile
         *
         *     Used to update user profile information. All fields are optional - only
         *     provided fields will be updated. The user_id is automatically extracted
         *     from the authentication token.
         * @example {
         *       "firstName": "John",
         *       "lastName": "Doe",
         *       "bio": "Musician from New York",
         *       "location": "New York, NY",
         *       "themeColor": "#FF5733"
         *     }
         */
        UpdateProfileDto: {
            /**
             * @description Username (3-30 characters, only for initial profile creation)
             * @example johndoe
             */
            username?: string;
            /**
             * @description First name (1-50 characters)
             * @example John
             */
            firstName?: string;
            /**
             * @description Last name (1-50 characters)
             * @example Doe
             */
            lastName?: string;
            /**
             * @description Short bio (max 100 characters)
             * @example Musician from New York
             */
            bio?: string;
            /**
             * @description Detailed about me section (max 500 characters)
             * @example I'm a professional musician with 10 years of experience...
             */
            aboutMe?: string;
            /**
             * @description URL to user's avatar image
             * @example https://example.com/avatar.jpg
             */
            avatarUrl?: string;
            /**
             * @description User's location (1-100 characters)
             * @example New York, NY
             */
            location?: string;
            /**
             * @description Theme color in hex format
             * @example #FF5733
             */
            themeColor?: string;
            /**
             * @description URL to Spotify playlist
             * @example https://open.spotify.com/playlist/...
             */
            spotifyPlaylistUrl?: string;
            /**
             * Format: double
             * @description Phone country code (1-999)
             * @example 1
             */
            phoneCountryCode?: number;
            /**
             * Format: double
             * @description Phone number (4-15 digits, stored as bigint)
             * @example 1234567890
             */
            phoneNumber?: number;
            /**
             * Format: double
             * @description Year of birth
             * @example 1990
             */
            yearOfBirth?: number;
            /**
             * @description User type: "musician", "service_provider", or "other"
             * @example musician
             */
            userType?: string;
            /**
             * @description Whether user has completed onboarding
             * @example true
             */
            onboardingCompleted?: boolean;
            /**
             * @description Types of connections user is looking for
             * @example [
             *       "connect",
             *       "find-band"
             *     ]
             */
            lookingFor?: components["schemas"]["LookingForType"][];
        };
        /**
<<<<<<< HEAD
         * @description API response format for user social media links
         * @example {
         *       "userId": "user-123",
         *       "instagram": "johndoe",
         *       "twitter": "@johndoe",
         *       "youtube": "johndoechannel",
         *       "soundcloud": null,
         *       "facebook": null,
         *       "tiktok": null,
         *       "bandcamp": null
         *     }
         */
        UserSocialMediaResponse: {
            userId: string;
            instagram: string | null;
            twitter: string | null;
            facebook: string | null;
            youtube: string | null;
            soundcloud: string | null;
            tiktok: string | null;
            bandcamp: string | null;
        };
        /** @description DTO for updating user social media links */
        UpdateSocialMediaDto: {
            instagram?: string | null;
            twitter?: string | null;
            facebook?: string | null;
            youtube?: string | null;
            soundcloud?: string | null;
            tiktok?: string | null;
            bandcamp?: string | null;
        };
        /**
         * @description API response format for user FAQ answer with question
         * @example {
         *       "id": "faq-123",
         *       "questionId": "q-456",
         *       "question": "What genres do you specialize in?",
         *       "answer": "I specialize in electronic and ambient music",
         *       "createdAt": "2024-01-20T15:30:00Z"
         *     }
         */
        UserFaqResponse: {
            id: string;
            questionId: string;
            question: string;
            answer: string;
            createdAt: string | null;
        };
        /** @description DTO for creating/updating user FAQ answer */
        UpsertFaqDto: {
            questionId: string;
            answer: string;
        };
        /**
         * @description API response format for user's "looking for" preferences
         * @example {
         *       "userId": "user-123",
         *       "lookingForValue": "connect"
         *     }
         */
        UserLookingForResponse: {
            userId: string;
            /** @enum {string} */
            lookingForValue: "connect" | "promote" | "find-band" | "find-services";
        };
        /**
         * @description API response format for FAQ question
         * @example {
         *       "id": "q-456",
         *       "question": "What genres do you specialize in?",
         *       "displayOrder": 1,
         *       "isActive": true
         *     }
         */
        FaqQuestionResponse: {
            id: string;
            question: string;
            /** Format: double */
            displayOrder: number;
            isActive: boolean;
        };
        /**
         * @description API response format for a single uploaded file
         * @example {
         *       "id": "media-123",
         *       "url": "https://storage.supabase.co/.../image.jpg",
         *       "thumbnailUrl": "https://storage.supabase.co/.../thumb.jpg",
         *       "type": "image",
         *       "createdAt": "2024-01-20T15:30:00Z"
         *     }
         */
        UploadedFileResponse: {
            id: string;
            url: string;
            thumbnailUrl?: string | null;
            /** @enum {string} */
            type: "image" | "video";
            createdAt: string | null;
        };
        /**
         * @description API response format for batch file upload
         * @example {
         *       "files": [
         *         {
         *           "id": "media-123",
         *           "url": "https://storage.supabase.co/.../image1.jpg",
         *           "thumbnailUrl": null,
         *           "type": "image",
         *           "createdAt": "2024-01-20T15:30:00Z"
         *         },
         *         {
         *           "id": "media-124",
         *           "url": "https://storage.supabase.co/.../image2.jpg",
         *           "thumbnailUrl": null,
         *           "type": "image",
         *           "createdAt": "2024-01-20T15:30:00Z"
         *         }
         *       ]
         *     }
         */
        UploadResponse: {
            files: components["schemas"]["UploadedFileResponse"][];
=======
         * @description API response format for signed upload URL
         *
         *     Returns a temporary signed URL that allows direct client uploads to Supabase Storage.
         *     The client uses this URL to upload files directly, bypassing the backend.
         * @example {
         *       "signedUrl": "https://[project].supabase.co/storage/v1/object/sign/posts/user-123/file.jpg?...",
         *       "filePath": "posts/user-123/1234567890-abc123.jpg"
         *     }
         */
        SignedUrlResponse: {
            signedUrl: string;
            filePath: string;
        };
        /**
         * @description DTO for requesting a signed upload URL
         *
         *     Used to generate a temporary signed URL for direct client uploads to Supabase Storage.
         *     The client will use this signed URL to upload files directly, bypassing the backend.
         * @example {
         *       "fileName": "my-image.jpg",
         *       "fileType": "image/jpeg",
         *       "uploadType": "post"
         *     }
         */
        SignedUrlRequestDto: {
            /**
             * @description Original file name (used to determine file extension)
             * @example my-image.jpg
             */
            fileName: string;
            /**
             * @description MIME type of the file (used for validation)
             * @example image/jpeg
             */
            fileType: string;
            /**
             * @description Upload type: "post" for post media, "avatar" for profile pictures
             * @default post
             * @example post
             * @enum {string}
             */
            uploadType: "post" | "avatar";
>>>>>>> dev
        };
        /**
         * @description Search result for a user (from search_people)
         * @example {
         *       "type": "user",
         *       "id": "user-123",
         *       "username": "johndoe",
         *       "firstName": "John",
         *       "lastName": "Doe",
         *       "avatarUrl": "https://...",
         *       "bio": "Musician and producer",
         *       "location": "New York, NY",
         *       "genres": [
         *         "rock",
         *         "indie"
         *       ],
         *       "lookingFor": [
         *         "connect",
         *         "find-band"
         *       ],
         *       "isConnected": false,
         *       "relevance": 0.95
         *     }
         */
        UserSearchResult: {
            /** @enum {string} */
            type: "user";
            id: string;
            username: string;
            firstName: string;
            lastName: string;
            avatarUrl?: string | null;
            bio?: string | null;
            location?: string | null;
            genres?: unknown;
            lookingFor?: string[];
            isConnected: boolean;
            /** Format: double */
            relevance: number;
        };
        /**
         * @description Search result for a collaboration request (from search_collaborations)
         * @example {
         *       "type": "collaboration",
         *       "id": "post-123",
         *       "title": "Looking for Drummer",
         *       "description": "Rock band seeking experienced drummer",
         *       "authorId": "user-456",
         *       "authorUsername": "janedoe",
         *       "authorAvatarUrl": "https://...",
         *       "location": "Los Angeles, CA",
         *       "paidOpportunity": true,
         *       "genres": [
         *         "rock",
         *         "alternative"
         *       ],
         *       "createdAt": "2024-01-20T12:00:00Z",
         *       "relevance": 0.88
         *     }
         */
        CollaborationSearchResult: {
            /** @enum {string} */
            type: "collaboration";
            id: string;
            title: string;
            description: string;
            authorId: string;
            authorUsername: string;
            authorAvatarUrl?: string | null;
            location?: string | null;
            paidOpportunity: boolean;
            genres?: unknown;
            createdAt: string;
            /** Format: double */
            relevance: number;
        };
        /**
         * @description Search result for metadata/tags (from search_tags)
         * @example {
         *       "type": "tag",
         *       "id": "tag-123",
         *       "name": "indie-rock",
         *       "usageCount": 42,
         *       "relevance": 0.75
         *     }
         */
        TagSearchResult: {
            /** @enum {string} */
            type: "tag" | "genre" | "artist";
            id: string;
            name: string;
            /** Format: double */
            usageCount: number;
            /** Format: double */
            relevance: number;
        };
        /**
         * @description Search result for "For You" tab (from search_for_you)
         *     Polymorphic result that can be a user or collaboration
         * @example {
         *       "type": "for_you",
         *       "entityType": "user",
         *       "entityId": "user-123",
         *       "title": "John Doe",
         *       "subtitle": "Musician  New York, NY",
         *       "avatarUrl": "https://...",
         *       "matchReason": "Similar genres and location",
         *       "additionalInfo": {
         *         "genres": [
         *           "rock",
         *           "indie"
         *         ]
         *       },
         *       "relevance": 0.92
         *     }
         */
        ForYouSearchResult: {
            /** @enum {string} */
            type: "for_you";
            /** @enum {string} */
            entityType: "user" | "collaboration";
            entityId: string;
            title: string;
            subtitle: string;
            avatarUrl?: string | null;
            matchReason: string;
            additionalInfo?: unknown;
            /** Format: double */
            relevance: number;
        };
        /** @description Union type for all search results */
        SearchResult: components["schemas"]["UserSearchResult"] | components["schemas"]["CollaborationSearchResult"] | components["schemas"]["TagSearchResult"] | components["schemas"]["ForYouSearchResult"];
        /** @description API response format for search results */
        SearchResponse: {
            results: components["schemas"]["SearchResult"][];
            /** Format: double */
            total?: number;
        };
        /**
         * @description API response format for a user review
         *     Represents a 5-star rating and review text for a user
         * @example {
         *       "id": "review-123",
         *       "userId": "user-456",
         *       "reviewerId": "user-123",
         *       "rating": 5,
         *       "description": "Excellent collaborator, very professional!",
         *       "createdAt": "2024-01-20T15:30:00Z",
         *       "reviewer": {
         *         "id": "user-123",
         *         "username": "johndoe",
         *         "firstName": "John",
         *         "lastName": "Doe",
         *         "avatarUrl": "https://..."
         *       }
         *     }
         */
        ReviewResponse: {
            id: string;
            userId: string;
            reviewerId: string;
            /** Format: double */
            rating: number;
            description?: string | null;
            createdAt: string | null;
            reviewer?: {
                avatarUrl?: string | null;
                lastName?: string | null;
                firstName?: string | null;
                username: string;
                id: string;
            };
        };
        /** @description From T, pick a set of properties whose keys are in the union K */
        "Pick_ReviewInsert.Exclude_keyofReviewInsert.reviewer_id-or-user_id-or-created_at-or-id__": {
            description?: string;
            /** Format: double */
            rating: number;
        };
        /**
         * @description DTO for creating a review
         *
         *     Used when writing a review for a user.
         *     The reviewer_id is automatically extracted from the authentication token.
         * @example {
         *       "rating": 5,
         *       "description": "Great collaborator, very professional!"
         *     }
         */
        CreateReviewDto: {
            /**
             * @description Optional review description (max 500 characters)
             * @example Great collaborator, very professional!
             */
            description?: string | null;
            /**
             * Format: double
             * @description Rating from 1 to 5 stars
             * @example 5
             */
            rating: number;
        };
        /**
         * @description DTO for updating a review
         *
         *     Used when editing your own review.
         * @example {
         *       "rating": 4,
         *       "description": "Updated review description"
         *     }
         */
        UpdateReviewDto: {
            /**
             * Format: double
             * @description Updated rating from 1 to 5 stars
             * @example 4
             */
            rating?: number;
            /**
             * @description Updated review description (max 500 characters)
             * @example Updated review description
             */
            description?: string | null;
        };
        /**
         * @description API response format for a post with flattened relations
         *     This is the camelCase version of PostRow (database format)
         *     The mapper transforms PostRow (snake_case)  PostResponse (camelCase)
         */
        PostResponse: {
            id: string;
            /** @enum {string} */
            type: "note" | "request" | "story";
            title: string;
            description: string;
            authorId: string;
            createdAt: string | null;
            updatedAt: string | null;
            location: string | null;
            paidOpportunity: boolean | null;
            expiresAt: string | null;
            metadata?: {
                /** @enum {string} */
                type: "tag" | "genre" | "artist";
                name: string;
                id: string;
            }[];
            media?: {
                /** Format: double */
                displayOrder: number;
                /** @enum {string} */
                type: "image" | "video";
                thumbnailUrl?: string | null;
                url: string;
                id: string;
            }[];
            taggedUsers?: {
                avatarUrl?: string | null;
                lastName?: string | null;
                firstName?: string | null;
                username: string;
                id: string;
            }[];
            author?: {
                avatarUrl?: string | null;
                lastName?: string | null;
                firstName?: string | null;
                username: string;
                id: string;
            };
        };
        /** @enum {string} */
        PostType: "note" | "request" | "story";
        /**
         * @description DTO for media items attached to posts
         * @example {
         *       "url": "https://example.com/image.jpg",
         *       "thumbnailUrl": "https://example.com/thumb.jpg",
         *       "type": "image"
         *     }
         */
        MediaItemDto: {
            /**
             * @description URL to the media file
             * @example https://example.com/image.jpg
             */
            url: string;
            /**
             * @description Optional thumbnail URL for the media
             * @example https://example.com/thumb.jpg
             */
            thumbnailUrl?: string;
            /**
             * @description Media type: "image" or "video"
             * @example image
             */
            type: string;
        };
        /** @description From T, pick a set of properties whose keys are in the union K */
        "Pick_PostInsert.Exclude_keyofPostInsert.id-or-author_id-or-created_at-or-updated_at-or-search_vector__": {
            description: string;
            expires_at?: string;
            location?: string;
            paid_opportunity?: boolean;
            title: string;
            /** @enum {string} */
            type: "note" | "request" | "story";
        };
        /**
         * @description DTO for creating a new post
         *
         *     Used when creating a post (note, request, or story). The author_id is
         *     automatically extracted from the authentication token.
         *
         *     For "note" posts, you can include tags.
         *     For "request" posts, you can include genres and paidOpportunity flag.
         *     All post types can include media attachments and tagged users.
         * @example {
         *       "type": "note",
         *       "title": "My First Post",
         *       "description": "This is a detailed description of my post",
         *       "location": "New York, NY",
         *       "tags": [
         *         "music",
         *         "jazz"
         *       ],
         *       "media": [
         *         {
         *           "url": "https://example.com/image.jpg",
         *           "type": "image"
         *         }
         *       ]
         *     }
         */
        CreatePostBody: {
            /**
             * @description Post description (10-5000 characters)
             * @example I'm looking for an experienced drummer to join our band...
             */
            description: string;
            expires_at?: string;
            /**
             * @description Optional location where the post is relevant
             * @example New York, NY
             */
            location?: string | null;
            paid_opportunity?: boolean;
            /**
             * @description Post title (1-100 characters)
             * @example Looking for a drummer
             */
            title: string;
            /**
             * @description Post type: "note", "request", or "story"
             * @example note
             */
            type: components["schemas"]["PostType"];
            /**
             * @description Whether this is a paid opportunity (only for "request" type posts)
             * @example true
             */
            paidOpportunity?: boolean | null;
            /**
             * @description Optional expiration date/time (ISO 8601 format)
             * @example 2024-12-31T23:59:59Z
             */
            expiresAt?: string | null;
            /**
             * @description Tags for "note" type posts
             * @example [
             *       "music",
             *       "jazz",
             *       "performance"
             *     ]
             */
            tags?: string[];
            /**
             * @description Genres for "request" type posts
             * @example [
             *       "rock",
             *       "pop",
             *       "indie"
             *     ]
             */
            genres?: string[];
            /**
             * @description Array of user IDs to tag in the post
             * @example [
             *       "123e4567-e89b-12d3-a456-426614174000"
             *     ]
             */
            taggedUsers?: string[];
            /**
             * @description Media attachments (images or videos)
             * @example [
             *       {
             *         "url": "https://example.com/image.jpg",
             *         "type": "image"
             *       }
             *     ]
             */
            media?: components["schemas"]["MediaItemDto"][];
        };
<<<<<<< HEAD
=======
        /** @description Generic paginated response wrapper */
        PaginatedResponse_PostResponse_: {
            data: components["schemas"]["PostResponse"][];
            pagination: {
                /** Format: double */
                total?: number;
                hasMore: boolean;
                nextCursor?: string;
            };
        };
        /**
         * @description API response format for a comment
         *     Represents a comment on a post with author information
         * @example {
         *       "id": "comment-123",
         *       "postId": "post-123",
         *       "authorId": "user-456",
         *       "content": "Great track! Love the production.",
         *       "createdAt": "2024-01-20T16:00:00Z",
         *       "updatedAt": "2024-01-20T16:00:00Z",
         *       "author": {
         *         "id": "user-456",
         *         "username": "janedoe",
         *         "firstName": "Jane",
         *         "lastName": "Doe",
         *         "avatarUrl": "https://..."
         *       }
         *     }
         */
        CommentResponse: {
            id: string;
            postId: string;
            authorId: string;
            content: string;
            createdAt: string | null;
            updatedAt: string | null;
            author?: {
                avatarUrl?: string | null;
                lastName?: string | null;
                firstName?: string | null;
                username: string;
                id: string;
            };
        };
>>>>>>> dev
        /**
         * @description API response format for a notification
         *     Represents a notification with actor information
         */
        NotificationResponse: {
            id: string;
            recipientId: string;
            actorId?: string | null;
            type: string;
            entityType?: string | null;
            entityId?: string | null;
            title: string;
            body?: string | null;
            actionUrl?: string | null;
            isRead: boolean | null;
            isArchived: boolean | null;
            createdAt: string | null;
            readAt?: string | null;
            sentViaWebsocket: boolean | null;
            actor?: {
                avatarUrl?: string | null;
                lastName?: string | null;
                firstName?: string | null;
                username: string;
                id: string;
            };
        };
        /**
         * @description DTO for updating a notification
         *
         *     Used when marking a notification as read or unread.
         * @example {
         *       "isRead": true
         *     }
         */
        UpdateNotificationDto: {
            /**
             * @description Whether the notification is read
             * @example true
             */
            isRead: boolean;
        };
        /**
         * @description API response format for metadata item
         * @example {
         *       "id": "abc123",
         *       "type": "tag",
         *       "name": "indie-rock",
         *       "createdAt": "2024-01-15T10:30:00Z"
         *     }
         */
        MetadataItem: {
            id: string;
            /** @enum {string} */
            type: "tag" | "genre" | "artist";
            name: string;
            createdAt: string | null;
        };
        /**
         * @description API response format for metadata endpoint
         *     Returns all available tags, genres, and artists organized by type
         * @example {
         *       "tags": [
         *         {
         *           "id": "1",
         *           "type": "tag",
         *           "name": "indie",
         *           "createdAt": "2024-01-15T10:30:00Z"
         *         }
         *       ],
         *       "genres": [
         *         {
         *           "id": "2",
         *           "type": "genre",
         *           "name": "Rock",
         *           "createdAt": "2024-01-15T10:30:00Z"
         *         }
         *       ],
         *       "artists": [
         *         {
         *           "id": "3",
         *           "type": "artist",
         *           "name": "The Beatles",
         *           "createdAt": "2024-01-15T10:30:00Z"
         *         }
         *       ]
         *     }
         */
        MetadataResponse: {
            tags: components["schemas"]["MetadataItem"][];
            genres: components["schemas"]["MetadataItem"][];
            artists: components["schemas"]["MetadataItem"][];
        };
<<<<<<< HEAD
        "SelectQueryError_columnstatusdoesnotexistonmessages._": {
            /** @enum {boolean} */
            error: true;
        } & "column 'status' does not exist on 'messages'.";
=======
        /**
         * @description API response format for a message
         *     Represents a message in a conversation with sender info and optional reply
         */
        MessageResponse: {
            id: string;
            conversationId: string;
            senderId: string;
            content: string | null;
            mediaIds?: string[] | null;
            isEdited: boolean | null;
            editedAt?: string | null;
            isDeleted: boolean | null;
            deletedAt?: string | null;
            replyToMessageId?: string | null;
            createdAt: string | null;
            sentViaWebsocket: boolean | null;
            sender?: {
                avatarUrl?: string | null;
                lastName?: string | null;
                firstName?: string | null;
                username: string;
                id: string;
            };
            replyTo?: components["schemas"]["MessageResponse"] | null;
            readReceipts?: components["schemas"]["MessageReadReceiptResponse"][];
            media?: {
                type: string;
                thumbnailUrl?: string | null;
                url: string;
                id: string;
            }[];
        };
        /**
         * @description API response format for a message read receipt
         * @example {
         *       "messageId": "msg-789",
         *       "userId": "user-456",
         *       "readAt": "2024-01-20T16:05:00Z",
         *       "user": {
         *         "id": "user-456",
         *         "username": "janedoe",
         *         "firstName": "Jane",
         *         "lastName": "Doe",
         *         "avatarUrl": "https://..."
         *       }
         *     }
         */
        MessageReadReceiptResponse: {
            messageId: string;
            userId: string;
            readAt: string | null;
            user?: {
                avatarUrl?: string | null;
                lastName?: string | null;
                firstName?: string | null;
                username: string;
                id: string;
            };
        };
        /**
         * @description API response format for paginated messages
         *     Used by GET /messages/:conversationId endpoint
         */
        PaginatedMessagesResponse: {
            messages: components["schemas"]["MessageResponse"][];
            hasMore: boolean;
            nextCursor: string | null;
        };
>>>>>>> dev
        SendMessageDto: {
            conversation_id: string;
            content: string;
            media_ids?: string[];
            reply_to_message_id?: string | null;
        };
        EditMessageDto: {
            content: string;
        };
        MarkMessagesReadDto: {
            message_ids: string[];
        };
        /**
         * @description API response format for a post in the feed
         *     Extends PostResponse with engagement data and user interaction state
         */
        FeedPostResponse: {
            id: string;
            /** @enum {string} */
            type: "note" | "request" | "story";
            title: string;
            description: string;
            authorId: string;
            createdAt: string | null;
            updatedAt: string | null;
            location: string | null;
            paidOpportunity: boolean | null;
            expiresAt: string | null;
            metadata?: {
                /** @enum {string} */
                type: "tag" | "genre" | "artist";
                name: string;
                id: string;
            }[];
            media?: {
                /** Format: double */
                displayOrder: number;
                /** @enum {string} */
                type: "image" | "video";
                thumbnailUrl?: string | null;
                url: string;
                id: string;
            }[];
            taggedUsers?: {
                avatarUrl?: string | null;
                lastName?: string | null;
                firstName?: string | null;
                username: string;
                id: string;
            }[];
            author?: {
                avatarUrl?: string | null;
                lastName?: string | null;
                firstName?: string | null;
                username: string;
                id: string;
            };
            /** Format: double */
            likesCount?: number;
            /** Format: double */
            commentsCount?: number;
            /** Format: double */
            bookmarksCount?: number;
            hasLiked?: boolean;
            hasBookmarked?: boolean;
        };
        /** @description API response format for a conversation participant */
        ConversationParticipantResponse: {
            userId: string;
            conversationId: string;
            joinedAt: string | null;
            leftAt?: string | null;
            isAdmin: boolean | null;
            lastReadMessageId?: string | null;
            lastReadAt?: string | null;
            notificationsEnabled: boolean | null;
            isMuted: boolean | null;
            user?: {
                avatarUrl?: string | null;
                lastName?: string | null;
                firstName?: string | null;
                username: string;
                id: string;
            };
        };
        /**
         * @description API response format for a conversation
         *     Represents a direct message or group conversation
         */
        ConversationResponse: {
            id: string;
            /** @enum {string} */
            type: "direct" | "group";
            name?: string | null;
            avatarUrl?: string | null;
            createdBy: string;
            createdAt: string | null;
            updatedAt: string | null;
            lastMessageId?: string | null;
            lastMessagePreview?: string | null;
            lastMessageAt?: string | null;
<<<<<<< HEAD
=======
            lastMessageSenderId?: string | null;
>>>>>>> dev
            /** Format: double */
            unreadCount: number;
            creator?: {
                avatarUrl?: string | null;
                lastName?: string | null;
                firstName?: string | null;
                username: string;
                id: string;
            };
            participants?: components["schemas"]["ConversationParticipantResponse"][];
        };
        /** @enum {string} */
        ConversationType: "direct" | "group";
        CreateConversationDto: {
            type: components["schemas"]["ConversationType"];
            name?: string | null;
            avatarUrl?: string | null;
            participantIds: string[];
        };
        UpdateConversationDto: {
            name?: string | null;
            avatarUrl?: string | null;
        };
        /**
         * @description Status of a connection request between two users
         * @enum {string}
         */
        ConnectionStatus: "pending" | "accepted" | "rejected";
        /**
         * @description API response format for a connection request
         *     Represents a connection request between two users with requester/recipient profiles
         */
        Connection: {
            id: string;
            requesterId: string;
            recipientId: string;
            status: components["schemas"]["ConnectionStatus"];
            createdAt: string | null;
            updatedAt: string | null;
            requester?: components["schemas"]["UserProfile"];
            recipient?: components["schemas"]["UserProfile"];
        };
<<<<<<< HEAD
        /** @description From T, pick a set of properties whose keys are in the union K */
        "Pick_ConnectionRequestInsert.Exclude_keyofConnectionRequestInsert.requester_id-or-created_at-or-updated_at-or-id-or-status__": {
            recipient_id: string;
        };
=======
>>>>>>> dev
        /**
         * @description DTO for creating a connection request
         *
         *     Used when sending a connection request to another user.
         *     The requester_id is automatically extracted from the authentication token.
         * @example {
         *       "recipientId": "a1b2c3d4-e5f6-7890-1234-567890abcdef"
         *     }
         */
        CreateConnectionRequestDto: {
<<<<<<< HEAD
            recipient_id: string;
=======
>>>>>>> dev
            /**
             * @description The ID of the user to send the connection request to (UUID format)
             * @example a1b2c3d4-e5f6-7890-1234-567890abcdef
             */
            recipientId: string;
        };
        /**
         * @description DTO for updating a connection request status
         *
         *     Used when accepting or rejecting a connection request.
         *     Only the recipient can update the status.
         * @example {
         *       "status": "accepted"
         *     }
         */
        UpdateConnectionRequestDto: {
            /**
             * @description The new status for the connection request
             * @example accepted
             */
            status: components["schemas"]["ConnectionStatus"];
        };
<<<<<<< HEAD
        /**
         * @description API response format for a comment
         *     Represents a comment on a post with author information
         * @example {
         *       "id": "comment-123",
         *       "postId": "post-123",
         *       "authorId": "user-456",
         *       "content": "Great track! Love the production.",
         *       "createdAt": "2024-01-20T16:00:00Z",
         *       "updatedAt": "2024-01-20T16:00:00Z",
         *       "author": {
         *         "id": "user-456",
         *         "username": "janedoe",
         *         "firstName": "Jane",
         *         "lastName": "Doe",
         *         "avatarUrl": "https://..."
         *       }
         *     }
         */
        CommentResponse: {
            id: string;
            postId: string;
            authorId: string;
            content: string;
            createdAt: string | null;
            updatedAt: string | null;
            author?: {
                avatarUrl?: string | null;
                lastName?: string | null;
                firstName?: string | null;
                username: string;
                id: string;
            };
        };
=======
>>>>>>> dev
        /** @description From T, pick a set of properties whose keys are in the union K */
        "Pick_CommentInsert.Exclude_keyofCommentInsert.author_id-or-created_at-or-updated_at-or-id__": {
            post_id: string;
            content: string;
        };
        /**
         * @description DTO for creating a comment
         *
         *     Used when creating a comment on a post. The author_id is automatically
         *     extracted from the authentication token.
         * @example {
         *       "postId": "a1b2c3d4-e5f6-7890-1234-567890abcdef",
         *       "content": "Great post! Looking forward to collaborating."
         *     }
         */
        CreateCommentDto: {
            post_id: string;
            /**
             * @description The comment content (1-1000 characters)
             * @example Great post! Looking forward to collaborating.
             */
            content: string;
            /**
             * @description The ID of the post to comment on (UUID format)
             * @example a1b2c3d4-e5f6-7890-1234-567890abcdef
             */
            postId: string;
        };
        /**
         * @description DTO for updating a comment
         *
         *     Used when updating an existing comment. Only the content can be updated.
         * @example {
         *       "content": "Updated comment text"
         *     }
         */
        UpdateCommentDto: {
            /**
             * @description The updated comment content (1-1000 characters)
             * @example Updated comment text
             */
            content: string;
        };
        /**
         * @description API response format for a user collaboration
         *     Represents a past collaboration between two users
         * @example {
         *       "id": "collab-123",
         *       "userId": "user-123",
         *       "collaboratorId": "user-456",
         *       "description": "Worked together on album production",
         *       "createdAt": "2024-01-20T15:30:00Z",
         *       "collaborator": {
         *         "id": "user-456",
         *         "username": "janedoe",
         *         "firstName": "Jane",
         *         "lastName": "Doe",
         *         "avatarUrl": "https://..."
         *       }
         *     }
         */
        CollaborationResponse: {
            id: string;
            userId: string;
            collaboratorId: string;
            description?: string | null;
            createdAt: string | null;
            collaborator?: {
                avatarUrl?: string | null;
                lastName?: string | null;
                firstName?: string | null;
                username: string;
                id: string;
            };
        };
        /** @description From T, pick a set of properties whose keys are in the union K */
        "Pick_CollaborationInsert.Exclude_keyofCollaborationInsert.user_id-or-created_at-or-id__": {
            description?: string;
            collaborator_id: string;
        };
        /**
         * @description DTO for creating a collaboration
         *
         *     Represents a past collaboration between the authenticated user and another user.
         *     The description is optional and limited to 200 characters.
         * @example {
         *       "collaboratorId": "a1b2c3d4-e5f6-7890-1234-567890abcdef",
         *       "description": "Worked together on a jazz album in 2023"
         *     }
         */
        CreateCollaborationDto: {
            /**
             * @description Optional description of the collaboration (max 200 characters)
             * @example Worked together on a jazz album in 2023
             */
            description?: string | null;
            collaborator_id: string;
            /**
             * @description The ID of the user you collaborated with (UUID format)
             * @example a1b2c3d4-e5f6-7890-1234-567890abcdef
             */
            collaboratorId: string;
        };
        /**
         * @description API response format for a bookmark
         *     Includes the bookmark details and optional post information with author
         * @example {
         *       "postId": "post-123",
         *       "userId": "user-456",
         *       "createdAt": "2024-01-20T15:30:00Z",
         *       "post": {
         *         "id": "post-123",
         *         "title": "New Song Release",
         *         "description": "Check it out!",
         *         "type": "note",
         *         "location": null,
         *         "createdAt": "2024-01-20T12:00:00Z",
         *         "author": {
         *           "id": "user-123",
         *           "username": "johndoe",
         *           "firstName": "John",
         *           "lastName": "Doe",
         *           "avatarUrl": "https://..."
         *         }
         *       }
         *     }
         */
        BookmarkResponse: {
            postId: string;
            userId: string;
            createdAt: string | null;
            post?: {
                author?: {
                    avatarUrl: string | null;
                    lastName: string;
                    firstName: string;
                    username: string;
                    id: string;
                };
                createdAt: string | null;
                location: string | null;
                type: string;
                description: string;
                title: string;
                id: string;
            };
        };
        /** @description From T, pick a set of properties whose keys are in the union K */
        "Pick_BookmarkInsert.Exclude_keyofBookmarkInsert.user_id-or-created_at__": {
            post_id: string;
        };
        /**
         * @description DTO for creating a bookmark
         *
         *     Used when a user wants to bookmark a post for later reference.
         *     The user_id is automatically extracted from the authentication token.
         * @example {
         *       "postId": "123e4567-e89b-12d3-a456-426614174000"
         *     }
         */
        CreateBookmarkDto: {
            post_id: string;
            /**
             * @description The UUID of the post to bookmark
             * @example 123e4567-e89b-12d3-a456-426614174000
             */
            postId: string;
        };
    };
    responses: never;
    parameters: never;
    requestBodies: never;
    headers: never;
    pathItems: never;
}
export type $defs = Record<string, never>;
export interface operations {
    GetUser: {
        parameters: {
            query?: never;
            header?: {
                Authorization?: string;
            };
            path: {
                /** @description The username of the user to retrieve */
                username: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description User profile (public or private based on authentication) */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["UserProfile"];
                };
            };
        };
    };
    UpdateProfile: {
        parameters: {
            query?: never;
            header?: {
                Authorization?: string;
            };
            path: {
                /** @description The username of the profile to update (must match authenticated user) */
                username: string;
            };
            cookie?: never;
        };
        /** @description The profile fields to update (all optional) */
        requestBody: {
            content: {
                "application/json": components["schemas"]["UpdateProfileDto"];
            };
        };
        responses: {
            /** @description Updated user profile */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["UserProfile"];
                };
            };
        };
    };
<<<<<<< HEAD
    GetUserSocialMedia: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The username of the user */
                username: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description User's social media links */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["UserSocialMediaResponse"];
                };
            };
        };
    };
    UpdateUserSocialMedia: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The username (must match authenticated user) */
                username: string;
            };
            cookie?: never;
        };
        /** @description Social media links to update */
        requestBody: {
            content: {
                "application/json": components["schemas"]["UpdateSocialMediaDto"];
            };
        };
        responses: {
            /** @description Updated social media links */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["UserSocialMediaResponse"];
                };
            };
        };
    };
    GetUserFaq: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The username of the user */
                username: string;
            };
=======
    GenerateSignedUploadUrl: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Request body containing fileName, fileType, and optional uploadType */
        requestBody: {
            content: {
                "application/json": components["schemas"]["SignedUrlRequestDto"];
            };
        };
        responses: {
            /** @description Signed URL and file path for direct client upload */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["SignedUrlResponse"];
                };
            };
        };
    };
    DeleteMedia: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The UUID of the media to delete */
                mediaId: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description No content */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    Search: {
        parameters: {
            query?: {
                /** @description Search query string */
                q?: string;
                /** @description Search tab: "for_you", "people", "collaborations", or "tags" (default: "for_you") */
                tab?: "for_you" | "people" | "collaborations" | "tags";
                /** @description Filter by location */
                location?: string;
                /** @description Filter by genres (array) */
                genres?: string[];
                /** @description Filter by looking for types (for people tab) */
                lookingFor?: string[];
                /** @description Filter for paid opportunities only (for collaborations tab) */
                paidOnly?: boolean;
                /** @description Maximum number of results (1-100, default: 20) */
                limit?: number;
                /** @description Offset for pagination (default: 0) */
                offset?: number;
            };
            header?: never;
            path?: never;
>>>>>>> dev
            cookie?: never;
        };
        requestBody?: never;
        responses: {
<<<<<<< HEAD
            /** @description User's FAQ answers with questions */
=======
            /** @description Search results based on the selected tab */
>>>>>>> dev
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
<<<<<<< HEAD
                    "application/json": components["schemas"]["UserFaqResponse"][];
=======
                    "application/json": components["schemas"]["SearchResponse"];
>>>>>>> dev
                };
            };
        };
    };
<<<<<<< HEAD
    UpsertUserFaq: {
=======
    GetUserReviews: {
>>>>>>> dev
        parameters: {
            query?: never;
            header?: never;
            path: {
<<<<<<< HEAD
                /** @description The username (must match authenticated user) */
=======
                /** @description The username of the user to retrieve reviews for */
>>>>>>> dev
                username: string;
            };
            cookie?: never;
        };
<<<<<<< HEAD
        /** @description Question ID and answer */
        requestBody: {
            content: {
                "application/json": components["schemas"]["UpsertFaqDto"];
            };
        };
        responses: {
            /** @description The created/updated FAQ answer */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["UserFaqResponse"];
                };
            };
        };
    };
    DeleteUserFaq: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The username (must match authenticated user) */
                username: string;
                /** @description The question ID to delete answer for */
                questionId: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description No content */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    GetUserLookingFor: {
=======
        requestBody?: never;
        responses: {
            /** @description Array of reviews with reviewer details */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ReviewResponse"][];
                };
            };
        };
    };
    CreateReview: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The username of the user being reviewed */
                username: string;
            };
            cookie?: never;
        };
        /** @description Review data including rating (1-5) and optional description */
        requestBody: {
            content: {
                "application/json": components["schemas"]["CreateReviewDto"];
            };
        };
        responses: {
            /** @description The newly created review */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ReviewResponse"];
                };
            };
        };
    };
    GetReview: {
>>>>>>> dev
        parameters: {
            query?: never;
            header?: never;
            path: {
<<<<<<< HEAD
                /** @description The username of the user */
                username: string;
=======
                /** @description The UUID of the review to retrieve */
                reviewId: string;
>>>>>>> dev
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
<<<<<<< HEAD
            /** @description User's looking for preferences */
=======
            /** @description The review with reviewer details */
>>>>>>> dev
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
<<<<<<< HEAD
                    "application/json": components["schemas"]["UserLookingForResponse"][];
=======
                    "application/json": components["schemas"]["ReviewResponse"];
>>>>>>> dev
                };
            };
        };
    };
<<<<<<< HEAD
    GetAllFaqQuestions: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
=======
    DeleteReview: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The UUID of the review to delete */
                reviewId: string;
            };
>>>>>>> dev
            cookie?: never;
        };
        requestBody?: never;
        responses: {
<<<<<<< HEAD
            /** @description List of all active FAQ questions */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["FaqQuestionResponse"][];
                };
            };
        };
    };
    UploadFiles: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "multipart/form-data": {
                    /** @description Array of files to upload (multipart/form-data) */
                    files: string[];
                    /** @description Upload type: "post" for post media, "avatar" for profile pictures */
                    type: string;
                    /** @description Whether to generate thumbnails for videos (default: false) */
                    generateThumbnails?: string;
                };
            };
        };
        responses: {
            /** @description Array of uploaded file records with URLs */
=======
            /** @description No content */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    UpdateReview: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The UUID of the review to update */
                reviewId: string;
            };
            cookie?: never;
        };
        /** @description Updated review data (rating and/or description) */
        requestBody: {
            content: {
                "application/json": components["schemas"]["UpdateReviewDto"];
            };
        };
        responses: {
            /** @description The updated review */
>>>>>>> dev
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
<<<<<<< HEAD
                    "application/json": components["schemas"]["UploadResponse"];
=======
                    "application/json": components["schemas"]["ReviewResponse"];
>>>>>>> dev
                };
            };
        };
    };
<<<<<<< HEAD
    DeleteMedia: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The UUID of the media to delete */
                mediaId: string;
            };
=======
    ListPosts: {
        parameters: {
            query?: {
                /** @description Filter by post type: "note", "request", or "story" */
                type?: "note" | "request" | "story";
                /** @description Filter by author user ID */
                authorId?: string;
                /** @description Cursor for pagination (ISO timestamp) */
                cursor?: string;
                /** @description Maximum number of posts to return (1-100, default: 20) */
                limit?: number;
                /** @description Whether to include engagement data (requires auth) */
                includeEngagement?: boolean;
                /** @description Whether to include media in the response */
                includeMedia?: boolean;
                /** @description Filter by genre IDs (array) */
                genreIds?: string[];
                /** @description Filter by tag names (array) */
                tags?: string[];
                /** @description Filter by location */
                location?: string;
                /** @description Filter for paid opportunities only */
                paidOnly?: boolean;
            };
            header?: never;
            path?: never;
>>>>>>> dev
            cookie?: never;
        };
        requestBody?: never;
        responses: {
<<<<<<< HEAD
            /** @description No content */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    Search: {
        parameters: {
            query?: {
                /** @description Search query string */
                q?: string;
                /** @description Search tab: "for_you", "people", "collaborations", or "tags" (default: "for_you") */
                tab?: "for_you" | "people" | "collaborations" | "tags";
                /** @description Filter by location */
                location?: string;
                /** @description Filter by genres (array) */
                genres?: string[];
                /** @description Filter by looking for types (for people tab) */
                lookingFor?: string[];
                /** @description Filter for paid opportunities only (for collaborations tab) */
                paidOnly?: boolean;
                /** @description Maximum number of results (1-100, default: 20) */
                limit?: number;
                /** @description Offset for pagination (default: 0) */
                offset?: number;
            };
=======
            /** @description Paginated list of posts */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["PaginatedResponse_PostResponse_"];
                };
            };
        };
    };
    CreatePost: {
        parameters: {
            query?: never;
>>>>>>> dev
            header?: never;
            path?: never;
            cookie?: never;
        };
<<<<<<< HEAD
        requestBody?: never;
        responses: {
            /** @description Search results based on the selected tab */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["SearchResponse"];
                };
            };
        };
    };
    GetUserReviews: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The username of the user to retrieve reviews for */
                username: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Array of reviews with reviewer details */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ReviewResponse"][];
                };
            };
        };
    };
    CreateReview: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The username of the user being reviewed */
                username: string;
            };
            cookie?: never;
        };
        /** @description Review data including rating (1-5) and optional description */
        requestBody: {
            content: {
                "application/json": components["schemas"]["CreateReviewDto"];
            };
        };
        responses: {
            /** @description The newly created review */
=======
        /** @description The post data including type, title, description, and optional fields */
        requestBody: {
            content: {
                "application/json": components["schemas"]["CreatePostBody"];
            };
        };
        responses: {
            /** @description The created post with all related data (metadata, media, tagged users, author) */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["PostResponse"];
                };
            };
        };
    };
    GetPost: {
        parameters: {
            query?: {
                /** @description Whether to include comments in the response */
                includeComments?: boolean;
                /** @description Maximum number of comments to return (1-100, default: 50) */
                commentsLimit?: number;
            };
            header?: never;
            path: {
                /** @description The UUID of the post to retrieve */
                id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The post with all related data, optional comments, and optional engagement */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["PostResponse"] & {
                        hasBookmarked?: boolean;
                        hasLiked?: boolean;
                        /** Format: double */
                        bookmarksCount?: number;
                        /** Format: double */
                        commentsCount?: number;
                        /** Format: double */
                        likesCount?: number;
                        comments?: components["schemas"]["CommentResponse"][];
                    };
                };
            };
        };
    };
    GetNotifications: {
        parameters: {
            query?: {
                /** @description Filter by notification type */
                type?: string;
                /** @description If true, only return unread notifications */
                unreadOnly?: boolean;
                /** @description Cursor for pagination (ISO timestamp) */
                cursor?: string;
                /** @description Maximum number of notifications to return (1-100, default: 50) */
                limit?: number;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Notifications with pagination cursor */
>>>>>>> dev
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
<<<<<<< HEAD
                    "application/json": components["schemas"]["ReviewResponse"];
=======
                    "application/json": {
                        nextCursor?: string;
                        notifications: components["schemas"]["NotificationResponse"][];
                    };
>>>>>>> dev
                };
            };
        };
    };
<<<<<<< HEAD
    GetReview: {
=======
    GetNotification: {
>>>>>>> dev
        parameters: {
            query?: never;
            header?: never;
            path: {
<<<<<<< HEAD
                /** @description The UUID of the review to retrieve */
                reviewId: string;
=======
                /** @description The UUID of the notification to retrieve */
                notificationId: string;
>>>>>>> dev
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
<<<<<<< HEAD
            /** @description The review with reviewer details */
=======
            /** @description The notification with actor information */
>>>>>>> dev
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
<<<<<<< HEAD
                    "application/json": components["schemas"]["ReviewResponse"];
=======
                    "application/json": components["schemas"]["NotificationResponse"];
>>>>>>> dev
                };
            };
        };
    };
<<<<<<< HEAD
    DeleteReview: {
=======
    DeleteNotification: {
>>>>>>> dev
        parameters: {
            query?: never;
            header?: never;
            path: {
<<<<<<< HEAD
                /** @description The UUID of the review to delete */
                reviewId: string;
=======
                /** @description The UUID of the notification to delete */
                notificationId: string;
>>>>>>> dev
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description No content */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
<<<<<<< HEAD
    UpdateReview: {
=======
    UpdateNotification: {
>>>>>>> dev
        parameters: {
            query?: never;
            header?: never;
            path: {
<<<<<<< HEAD
                /** @description The UUID of the review to update */
                reviewId: string;
            };
            cookie?: never;
        };
        /** @description Updated review data (rating and/or description) */
        requestBody: {
            content: {
                "application/json": components["schemas"]["UpdateReviewDto"];
            };
        };
        responses: {
            /** @description The updated review */
=======
                /** @description The UUID of the notification to update */
                notificationId: string;
            };
            cookie?: never;
        };
        /** @description Update data including isRead status */
        requestBody: {
            content: {
                "application/json": components["schemas"]["UpdateNotificationDto"];
            };
        };
        responses: {
            /** @description The updated notification */
>>>>>>> dev
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
<<<<<<< HEAD
                    "application/json": components["schemas"]["ReviewResponse"];
=======
                    "application/json": components["schemas"]["NotificationResponse"];
>>>>>>> dev
                };
            };
        };
    };
<<<<<<< HEAD
    CreatePost: {
=======
    GetMetadata: {
>>>>>>> dev
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
<<<<<<< HEAD
        /** @description The post data including type, title, description, and optional fields */
        requestBody: {
            content: {
                "application/json": components["schemas"]["CreatePostBody"];
            };
        };
        responses: {
            /** @description The created post with all related data (metadata, media, tagged users, author) */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["PostResponse"];
                };
            };
        };
    };
    GetNotifications: {
        parameters: {
            query?: {
                /** @description Filter by notification type */
                type?: string;
                /** @description If true, only return unread notifications */
                unreadOnly?: boolean;
                /** @description Cursor for pagination (ISO timestamp) */
                cursor?: string;
                /** @description Maximum number of notifications to return (1-100, default: 50) */
                limit?: number;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Notifications with pagination cursor */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        nextCursor?: string;
                        notifications: components["schemas"]["NotificationResponse"][];
                    };
                };
            };
        };
    };
    GetNotification: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The UUID of the notification to retrieve */
                notificationId: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The notification with actor information */
=======
        requestBody?: never;
        responses: {
            /** @description Metadata grouped by type (tags, genres, artists) */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["MetadataResponse"];
                };
            };
        };
    };
    GetMessages: {
        parameters: {
            query?: {
                limit?: number;
                before_message_id?: string;
            };
            header?: never;
            path: {
                conversationId: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Ok */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["PaginatedMessagesResponse"];
                };
            };
        };
    };
    SendMessage: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["SendMessageDto"];
            };
        };
        responses: {
            /** @description Ok */
>>>>>>> dev
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
<<<<<<< HEAD
                    "application/json": components["schemas"]["NotificationResponse"];
=======
                    "application/json": components["schemas"]["MessageResponse"];
>>>>>>> dev
                };
            };
        };
    };
<<<<<<< HEAD
    DeleteNotification: {
=======
    EditMessage: {
>>>>>>> dev
        parameters: {
            query?: never;
            header?: never;
            path: {
<<<<<<< HEAD
                /** @description The UUID of the notification to delete */
                notificationId: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description No content */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    UpdateNotification: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The UUID of the notification to update */
                notificationId: string;
            };
            cookie?: never;
        };
        /** @description Update data including isRead status */
        requestBody: {
            content: {
                "application/json": components["schemas"]["UpdateNotificationDto"];
            };
        };
        responses: {
            /** @description The updated notification */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["NotificationResponse"];
                };
            };
        };
    };
    GetMetadata: {
=======
                messageId: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["EditMessageDto"];
            };
        };
        responses: {
            /** @description Ok */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        sent_via_websocket: boolean;
                        sender_id: string;
                        reply_to_message_id: string;
                        media_ids: string[];
                        is_edited: boolean;
                        is_deleted: boolean;
                        id: string;
                        edited_at: string;
                        deleted_at: string;
                        created_at: string;
                        conversation_id: string;
                        content: string;
                    };
                };
            };
        };
    };
    DeleteMessage: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                messageId: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description No content */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    MarkAsRead: {
>>>>>>> dev
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
<<<<<<< HEAD
        requestBody?: never;
        responses: {
            /** @description Metadata grouped by type (tags, genres, artists) */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["MetadataResponse"];
                };
            };
        };
    };
    GetMessages: {
        parameters: {
            query?: {
                limit?: number;
                before_message_id?: string;
            };
            header?: never;
            path: {
                conversationId: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Ok */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["SelectQueryError_columnstatusdoesnotexistonmessages._"][];
                };
            };
        };
    };
    SendMessage: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["SendMessageDto"];
            };
        };
        responses: {
            /** @description Ok */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        sender: {
                            avatar_url: string;
                            last_name: string;
                            first_name: string;
                            username: string;
                            id: string;
                        };
                        sent_via_websocket: boolean;
                        sender_id: string;
                        reply_to_message_id: string;
                        media_ids: string[];
                        is_edited: boolean;
                        is_deleted: boolean;
                        id: string;
                        edited_at: string;
                        deleted_at: string;
                        created_at: string;
                        conversation_id: string;
                        content: string;
                    };
                };
            };
        };
    };
    EditMessage: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                messageId: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["EditMessageDto"];
            };
        };
        responses: {
            /** @description Ok */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        sent_via_websocket: boolean;
                        sender_id: string;
                        reply_to_message_id: string;
                        media_ids: string[];
                        is_edited: boolean;
                        is_deleted: boolean;
                        id: string;
                        edited_at: string;
                        deleted_at: string;
                        created_at: string;
                        conversation_id: string;
                        content: string;
                    };
                };
            };
        };
    };
    DeleteMessage: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                messageId: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description No content */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    MarkAsRead: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
=======
>>>>>>> dev
        requestBody: {
            content: {
                "application/json": components["schemas"]["MarkMessagesReadDto"];
            };
        };
        responses: {
            /** @description Ok */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        success: boolean;
                    };
                };
            };
        };
    };
    SetTyping: {
        parameters: {
            query?: {
                isTyping?: boolean;
            };
            header?: never;
            path: {
                conversationId: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description No content */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    GetFeed: {
        parameters: {
            query?: {
                /** @description The feed component to fetch (default: "posts") */
                component?: "posts" | "recommendations" | "stories";
                /** @description Cursor for pagination (ISO timestamp) */
                cursor?: string;
                /** @description Maximum number of items to return (1-50, default: 20) */
                limit?: number;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Feed posts with pagination cursor, or recommendations array */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        nextCursor?: string;
                        posts: components["schemas"]["FeedPostResponse"][];
                    } | {
                        recommendations: components["schemas"]["FeedPostResponse"][];
                    } | {
                        stories: unknown[];
                    };
                };
            };
        };
    };
    GetConversations: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Ok */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ConversationResponse"][];
                };
            };
        };
    };
    CreateConversation: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["CreateConversationDto"];
            };
        };
        responses: {
            /** @description Ok */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ConversationResponse"];
                };
            };
        };
    };
    GetUnreadCount: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Ok */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /** Format: double */
                        unread_count: number;
                    };
                };
            };
        };
    };
    GetConversation: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                conversationId: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Ok */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ConversationResponse"];
                };
            };
        };
    };
    UpdateConversation: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                conversationId: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["UpdateConversationDto"];
            };
        };
        responses: {
            /** @description Ok */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ConversationResponse"];
                };
            };
        };
    };
    DeleteConversation: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                conversationId: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description No content */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    GetConnectionRequests: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Array of connection requests (sent and received) */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Connection"][];
                };
            };
        };
    };
    CreateConnectionRequest: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Connection request data including recipient ID */
        requestBody: {
            content: {
                "application/json": components["schemas"]["CreateConnectionRequestDto"];
            };
        };
        responses: {
            /** @description The created connection request */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Connection"];
                };
            };
        };
    };
    GetSentConnectionRequests: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The UUID of the user to retrieve sent requests for */
                userId: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Array of connection requests sent by the user */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Connection"][];
                };
            };
        };
    };
    GetReceivedConnectionRequests: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The UUID of the user to retrieve received requests for */
                userId: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Array of connection requests received by the user */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Connection"][];
                };
            };
        };
    };
<<<<<<< HEAD
=======
    GetConnectionStatus: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The UUID of the target user */
                targetUserId: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The connection if it exists, null otherwise */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Connection"] | null;
                };
            };
        };
    };
    GetUserAcceptedConnections: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The UUID of the user to retrieve accepted connections for */
                userId: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Array of accepted connections for the user */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Connection"][];
                };
            };
        };
    };
>>>>>>> dev
    UpdateConnectionRequest: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The UUID of the connection request to update */
                requestId: string;
            };
            cookie?: never;
        };
        /** @description Updated status (accepted or rejected) */
        requestBody: {
            content: {
                "application/json": components["schemas"]["UpdateConnectionRequestDto"];
            };
        };
        responses: {
            /** @description The updated connection request */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Connection"];
                };
            };
        };
    };
    DeleteConnectionRequest: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The UUID of the connection request to delete */
                requestId: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description No content */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    GetPostComments: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The UUID of the post to retrieve comments for */
                postId: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Array of comments with author details */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["CommentResponse"][];
                };
            };
        };
    };
    GetUserComments: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The UUID of the user to retrieve comments for */
                userId: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Array of comments with author details */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["CommentResponse"][];
                };
            };
        };
    };
    CreateComment: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Comment data including post ID and content */
        requestBody: {
            content: {
                "application/json": components["schemas"]["CreateCommentDto"];
            };
        };
        responses: {
            /** @description The created comment with author details */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["CommentResponse"];
                };
            };
        };
    };
    UpdateComment: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The UUID of the comment to update */
                commentId: string;
            };
            cookie?: never;
        };
        /** @description Updated comment content */
        requestBody: {
            content: {
                "application/json": components["schemas"]["UpdateCommentDto"];
            };
        };
        responses: {
            /** @description The updated comment */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["CommentResponse"];
                };
            };
        };
    };
    DeleteComment: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The UUID of the comment to delete */
                commentId: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description No content */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    GetCollaborations: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Array of collaborations with collaborator details */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["CollaborationResponse"][];
                };
            };
        };
    };
    CreateCollaboration: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Collaboration data including collaborator ID and optional description */
        requestBody: {
            content: {
                "application/json": components["schemas"]["CreateCollaborationDto"];
            };
        };
        responses: {
            /** @description The created collaboration */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["CollaborationResponse"];
                };
            };
        };
    };
    GetUserCollaborations: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The UUID of the user to retrieve collaborations for */
                userId: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Array of collaborations with collaborator details */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["CollaborationResponse"][];
                };
            };
        };
    };
    DeleteCollaboration: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The UUID of the collaboration to delete */
                collaborationId: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description No content */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    GetBookmarks: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Array of bookmarks with post details */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["BookmarkResponse"][];
                };
            };
        };
    };
    CreateBookmark: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description The bookmark data containing the post ID to bookmark */
        requestBody: {
            content: {
                "application/json": components["schemas"]["CreateBookmarkDto"];
            };
        };
        responses: {
            /** @description The created bookmark */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["BookmarkResponse"];
                };
            };
        };
    };
    DeleteBookmark: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The UUID of the post to unbookmark */
                postId: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description No content */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    CheckUsername: {
        parameters: {
            query: {
                /** @description Username to check for availability */
                username: string;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Object containing available boolean */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        available: boolean;
                    };
                };
            };
        };
    };
}
