/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export interface paths {
    "/users/{username}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get user profile
         * @description Get user profile by username
         *
         *     Retrieves a user's profile information. Returns public profile data by default.
         *     If authenticated and viewing your own profile, returns additional private fields
         *     such as phone number, year of birth, etc.
         *
         *     Authentication is optional - endpoint can be accessed without a token for public profiles.
         */
        get: operations["GetUser"];
        /**
         * Update user profile
         * @description Update own profile
         *
         *     Updates the authenticated user's profile information. Only the profile owner
         *     can update their own profile. All fields in the request body are optional -
         *     only provided fields will be updated.
         */
        put: operations["UpdateProfile"];
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/users/{userId}/block": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Block a user
         * @description Block a user
         *
         *     Blocks the specified user, adding them to your blocked users list.
         *     This will also remove any existing direct conversations between you and the blocked user.
         */
        post: operations["BlockUser"];
        /**
         * Unblock a user
         * @description Unblock a user
         *
         *     Removes the specified user from your blocked users list.
         */
        delete: operations["UnblockUser"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/users/{userId}/block-status": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get block status
         * @description Get block status between two users
         *
         *     Checks whether there is a block relationship between the authenticated user
         *     and the specified target user, and returns the direction of the block.
         */
        get: operations["GetBlockStatus"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/users/blocked": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get blocked users
         * @description Get list of blocked users
         *
         *     Returns a list of all users that the authenticated user has blocked.
         */
        get: operations["GetBlockedUsers"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/users/{username}/social-media": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get user social media
         * @description Get user's social media links
         *
         *     Returns all social media platform links for the specified user.
         *     This endpoint is public and does not require authentication.
         */
        get: operations["GetUserSocialMedia"];
        /**
         * Update user social media
         * @description Update user's social media links
         *
         *     Updates the authenticated user's social media links.
         *     Only the profile owner can update their own social media.
         */
        put: operations["UpdateUserSocialMedia"];
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/users/{username}/faq": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get user FAQ
         * @description Get user's FAQ answers
         *
         *     Returns all FAQ answers for the specified user with their corresponding questions.
         *     This endpoint is public and does not require authentication.
         */
        get: operations["GetUserFaq"];
        put?: never;
        /**
         * Upsert user FAQ answer
         * @description Create or update user's FAQ answer
         *
         *     Adds or updates an answer to an FAQ question for the authenticated user.
         *     Only the profile owner can manage their own FAQ.
         */
        post: operations["UpsertUserFaq"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/users/{username}/faq/{questionId}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post?: never;
        /**
         * Delete user FAQ answer
         * @description Delete user's FAQ answer
         *
         *     Removes an answer to an FAQ question for the authenticated user.
         *     Only the profile owner can delete their own FAQ answers.
         */
        delete: operations["DeleteUserFaq"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/users/{username}/looking-for": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get user looking for preferences
         * @description Get what user is looking for
         *
         *     Returns the user's "looking for" preferences (connect, promote, find-band, find-services).
         *     This endpoint is public and does not require authentication.
         */
        get: operations["GetUserLookingFor"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/faq-questions": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get all FAQ questions
         * @description Get all available FAQ questions
         *
         *     Returns all active FAQ questions that users can answer on their profiles.
         *     This endpoint is public and does not require authentication.
         */
        get: operations["GetAllFaqQuestions"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/upload/signed-url": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Generate signed upload URL
         * @description Generate a signed upload URL for direct client uploads
         *
         *     Returns a temporary signed URL that allows clients to upload files directly
         *     to Supabase Storage, bypassing the backend. This improves scalability by
         *     avoiding large file buffers in the Node.js server.
         *
         *     The client should:
         *     1. Call this endpoint to get a signed URL
         *     2. Upload the file directly to the signed URL using fetch/PUT
         *     3. Use the returned filePath to construct the public URL
         *     4. Include the public URL when creating posts or updating avatars
         *
         *     - **Images**: JPEG, PNG, GIF, WebP
         *     - **Videos**: MP4, WebM, QuickTime
         *     - **Upload Types**: "post" (default) for post media, "avatar" for profile pictures
         */
        post: operations["GenerateSignedUploadUrl"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/media/{mediaId}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post?: never;
        /**
         * Delete media
         * @description Delete a media file
         *
         *     Removes the file from Supabase Storage and deletes the media record from the database.
         *     Only authenticated users can delete media.
         */
        delete: operations["DeleteMedia"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/services": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List services
         * @description List services with optional filters
         *
         *     Returns a list of services with optional filtering by service type and location.
         *     Services are public and can be viewed without authentication.
         *     Services are seeded data - there is no creation endpoint.
         */
        get: operations["GetServices"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/search": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Search across users, posts, services, and tags
         * @description Search for users, posts, or tags
         *
         *     Performs a search across different entity types based on the specified tab.
         *     Returns polymorphic results that vary by tab type.
         *
         *     - **for_you**: Personalized results combining people and collaboration requests
         *     - **people**: Search for users with filters (location, genres, looking for)
         *     - **collaborations**: Search for collaboration request posts
         *     - **services**: Search for services
         *     - **tags**: Search for metadata (tags, genres, artists)
         */
        get: operations["Search"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/search/recent": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get recent searches
         * @description Get recent searches for the authenticated user
         *
         *     Returns the user's recent search history, ordered by most recent first.
         *     Limited to the last 15 searches by default.
         */
        get: operations["GetRecentSearches"];
        put?: never;
        /**
         * Save recent search
         * @description Save a recent search
         *
         *     Saves a search query to the user's recent search history.
         *     Automatically deduplicates identical query+tab combinations.
         */
        post: operations["SaveRecentSearch"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/search/recent/clear": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post?: never;
        /**
         * Clear all recent searches
         * @description Clear all recent searches
         *
         *     Removes all search entries from the user's recent search history.
         */
        delete: operations["ClearAllRecentSearches"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/search/recent/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post?: never;
        /**
         * Delete recent search
         * @description Delete a specific recent search
         *
         *     Removes a single search entry from the user's recent search history.
         */
        delete: operations["DeleteRecentSearch"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/users/{username}/reviews": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get user reviews
         * @description Get all reviews for a user
         *
         *     Returns all reviews for a specific user with reviewer information.
         *     This endpoint is public and does not require authentication.
         */
        get: operations["GetUserReviews"];
        put?: never;
        /**
         * Create a review
         * @description Create a review for a user
         *
         *     Allows the authenticated user to write a review for another user.
         *     Prevents self-reviews and duplicate reviews.
         */
        post: operations["CreateReview"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/reviews/{reviewId}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get review by ID
         * @description Get a review by ID
         *
         *     Returns a specific review with reviewer information.
         *     This endpoint is public and does not require authentication.
         */
        get: operations["GetReview"];
        put?: never;
        post?: never;
        /**
         * Delete a review
         * @description Delete a review
         *
         *     Permanently deletes a review.
         *     Only the reviewer can delete their own review.
         */
        delete: operations["DeleteReview"];
        options?: never;
        head?: never;
        /**
         * Update a review
         * @description Update a review
         *
         *     Updates the rating and/or description of a review.
         *     Only the reviewer can update their own review.
         */
        patch: operations["UpdateReview"];
        trace?: never;
    };
    "/posts": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List posts
         * @description List posts with filters and pagination
         *
         *     Returns a paginated list of posts with optional filters.
         *     Supports filtering by type, author, location, genres, tags, and paid opportunities.
         *     Can optionally include engagement data (requires authentication).
         *
         *     Posts are public and can be viewed without authentication, but engagement data
         *     (likes, comments, bookmarks) requires authentication.
         */
        get: operations["ListPosts"];
        put?: never;
        /**
         * Create a post
         * @description Create a new post
         *
         *     Creates a new post (note, request, or story) with optional metadata, media,
         *     and tagged users. The post is automatically associated with the authenticated user.
         *
         *     For "note" type posts, you can include tags.
         *     For "request" type posts, you can include genres and paid_opportunity flag.
         *     All post types can include media and tagged users.
         */
        post: operations["CreatePost"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/posts/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get post by ID
         * @description Get a single post by ID
         *
         *     Returns a single post with full details including author, metadata, media, and tagged users.
         *     Can optionally include comments and engagement data (requires authentication).
         *
         *     Posts are public and can be viewed without authentication, but engagement data
         *     (likes, comments, bookmarks) requires authentication.
         */
        get: operations["GetPost"];
        /**
         * Update a post
         * @description Update a post
         *
         *     Updates a post's content. Only the post author can update their own posts.
         */
        put: operations["UpdatePost"];
        post?: never;
        /**
         * Delete a post
         * @description Delete a post
         *
         *     Permanently deletes a post and all its related data.
         *     Only the post author can delete their own posts.
         */
        delete: operations["DeletePost"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/posts/{id}/resolve": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Resolve a request post
         * @description Resolve a request post
         *
         *     Marks a request post as resolved and archives it. Only the post author can resolve their own posts.
         *     Resolved posts are excluded from the main feed but remain accessible via user's post history.
         */
        post: operations["ResolvePost"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/posts/{id}/like": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Like a post
         * @description Like a post
         *
         *     Adds a like from the authenticated user to the specified post.
         *     If the post is already liked by the user, this is a no-op.
         */
        post: operations["LikePost"];
        /**
         * Unlike a post
         * @description Unlike a post
         *
         *     Removes the like from the authenticated user for the specified post.
         */
        delete: operations["UnlikePost"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/posts/{id}/respondents": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get post respondents
         * @description Get users who responded to a post by starting a chat
         *
         *     Returns a list of users who initiated a conversation in response to this request post.
         *     Only the post author can view respondents.
         */
        get: operations["GetPostRespondents"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/posts/respondents/all": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get all post respondents for current user
         * @description Get all respondents across all of the user's request posts
         *
         *     Returns unique users who have started chats on any of the user's request posts.
         *     This is useful for populating the "past collaborators" section on the profile.
         */
        get: operations["GetAllPostRespondents"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/notifications": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get user notifications
         * @description Get notifications for the authenticated user
         *
         *     Returns notifications for the authenticated user with optional filters.
         *     Supports filtering by type and unread status, with cursor-based pagination.
         *     When grouped=true, returns notifications organized by type for easy filtering.
         */
        get: operations["GetNotifications"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/notifications/{notificationId}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get notification by ID
         * @description Get a notification by ID
         *
         *     Returns a specific notification with actor information.
         *     Only the recipient can access their own notifications.
         */
        get: operations["GetNotification"];
        put?: never;
        post?: never;
        /**
         * Delete a notification
         * @description Delete a notification
         *
         *     Permanently deletes a notification.
         *     Only the recipient can delete their own notifications.
         */
        delete: operations["DeleteNotification"];
        options?: never;
        head?: never;
        /**
         * Mark notification as read/unread
         * @description Update a notification
         *
         *     Marks a notification as read or unread.
         *     Only the recipient can update their own notifications.
         */
        patch: operations["UpdateNotification"];
        trace?: never;
    };
    "/notifications/count": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get unread notification count
         * @description Get unread notification count
         *
         *     Returns the total count of unread notifications for the authenticated user.
         *     This is optimized for badge display and avoids fetching all notification data.
         */
        get: operations["GetUnreadCount"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/metadata": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get all metadata
         * @description Get all metadata
         *
         *     Returns all tags, genres, and artists grouped by type.
         *     Used for dropdowns, autocomplete, and tag/genre selectors.
         *     This endpoint is public and does not require authentication.
         */
        get: operations["GetMetadata"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/messages/{conversationId}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get: operations["GetMessages"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/messages": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post: operations["SendMessage"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/messages/{messageId}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put: operations["EditMessage"];
        post?: never;
        delete: operations["DeleteMessage"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/messages/read": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post: operations["MarkAsRead"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/messages/typing/{conversationId}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post: operations["SetTyping"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/feed": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get home feed
         * @description Get home feed
         *
         *     Returns feed content based on the specified component:
         *     - "posts": Posts from users you follow (with pagination)
         *     - "recommendations": Collaboration request recommendations
         *     - "stories": Stories from followed users (coming soon)
         *
         *     Posts feed includes engagement data (likes, comments, bookmarks counts)
         *     and user interaction state (hasLiked, hasBookmarked).
         */
        get: operations["GetFeed"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/conversations": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get: operations["GetConversations"];
        put?: never;
        post: operations["CreateConversation"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/conversations/unread-count": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get: operations["GetUnreadCount"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/conversations/{conversationId}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get: operations["GetConversation"];
        put: operations["UpdateConversation"];
        post?: never;
        delete: operations["DeleteConversation"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/conversations/{conversationId}/participants": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post: operations["AddParticipants"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/conversations/{conversationId}/participants/{userId}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post?: never;
        delete: operations["RemoveParticipant"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/connections": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get user's connection requests
         * @description Get all connection requests for the authenticated user
         *
         *     Returns both sent and received connection requests for the authenticated user.
         *     Each request includes requester and recipient profile information.
         */
        get: operations["GetConnectionRequests"];
        put?: never;
        /**
         * Send a connection request
         * @description Create a connection request
         *
         *     Allows the authenticated user to send a connection request to another user.
         *     The recipient must exist and there must not be an existing connection request.
         */
        post: operations["CreateConnectionRequest"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/connections/sent/{userId}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get sent connection requests by user
         * @description Get connection requests sent by a user
         *
         *     Returns all connection requests sent by the specified user.
         *     This endpoint can be accessed without authentication.
         */
        get: operations["GetSentConnectionRequests"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/connections/received/{userId}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get received connection requests by user
         * @description Get connection requests received by a user
         *
         *     Returns all connection requests received by the specified user.
         *     This endpoint can be accessed without authentication.
         */
        get: operations["GetReceivedConnectionRequests"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/connections/status/{targetUserId}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get connection status between two users
         * @description Get connection status between the authenticated user and another user
         *
         *     Returns the connection if it exists (pending, accepted), null otherwise.
         *     Rejected connections are not returned.
         */
        get: operations["GetConnectionStatus"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/connections/accepted/{userId}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get accepted connections by user
         * @description Get accepted connections for a specific user
         *
         *     Returns only accepted connections for the specified user.
         *     This endpoint can be accessed without authentication.
         */
        get: operations["GetUserAcceptedConnections"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/connections/{requestId}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        /**
         * Accept or reject a connection request
         * @description Update a connection request status
         *
         *     Allows the recipient to accept or reject a connection request.
         *     Only the recipient can update the status, and only pending requests can be updated.
         */
        put: operations["UpdateConnectionRequest"];
        post?: never;
        /**
         * Delete a connection request
         * @description Delete a connection request
         *
         *     Removes a connection request. Only the requester can delete a pending request.
         */
        delete: operations["DeleteConnectionRequest"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/comments/post/{postId}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get comments for a post
         * @description Get all comments for a post
         *
         *     Returns all comments on a specific post, ordered by creation date (oldest first).
         *     Each comment includes the author's profile information and like counts.
         *     If authenticated, also includes whether the user has liked each comment.
         */
        get: operations["GetPostComments"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/comments/user/{userId}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get comments by user
         * @description Get all comments by a user
         *
         *     Returns all comments created by a specific user, ordered by creation date (newest first).
         *     Each comment includes the author's profile information.
         */
        get: operations["GetUserComments"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/comments": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Create a comment
         * @description Create a comment on a post
         *
         *     Allows the authenticated user to create a comment on a post.
         *     The post must exist and the comment content must be between 1 and 1000 characters.
         */
        post: operations["CreateComment"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/comments/{commentId}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        /**
         * Update a comment
         * @description Update a comment
         *
         *     Allows the authenticated user to update their own comment.
         *     Only the comment author can update their comment.
         */
        put: operations["UpdateComment"];
        post?: never;
        /**
         * Delete a comment
         * @description Delete a comment
         *
         *     Removes a comment. Only the comment author can delete their own comment.
         */
        delete: operations["DeleteComment"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/comments/{commentId}/like": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Like a comment
         * @description Like a comment
         *
         *     Adds a like from the authenticated user to the specified comment.
         *     If the comment is already liked by the user, this is a no-op.
         */
        post: operations["LikeComment"];
        /**
         * Unlike a comment
         * @description Unlike a comment
         *
         *     Removes the like from the authenticated user for the specified comment.
         */
        delete: operations["UnlikeComment"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/collaborations": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get user's collaborations
         * @description Get all collaborations for the authenticated user
         *
         *     Returns a list of all collaborations where the authenticated user is involved.
         *     Each collaboration includes the collaborator's profile information.
         */
        get: operations["GetCollaborations"];
        put?: never;
        /**
         * Create a collaboration
         * @description Create a collaboration
         *
         *     Allows the authenticated user to record a past collaboration with another user.
         *     The collaborator must exist and the collaboration must not already exist.
         */
        post: operations["CreateCollaboration"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/collaborations/{userId}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get collaborations by user ID
         * @description Get collaborations for a specific user
         *
         *     Returns all collaborations for the specified user. This endpoint can be
         *     accessed without authentication to view public collaboration information.
         */
        get: operations["GetUserCollaborations"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/collaborations/{collaborationId}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post?: never;
        /**
         * Delete a collaboration
         * @description Delete a collaboration
         *
         *     Removes a collaboration. Only the user who created the collaboration
         *     can delete it.
         */
        delete: operations["DeleteCollaboration"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/bookmarks": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get user's bookmarks
         * @description Get all bookmarks for the authenticated user
         *
         *     Returns a list of all bookmarks created by the authenticated user.
         *     Each bookmark includes the post details and author information.
         */
        get: operations["GetBookmarks"];
        put?: never;
        /**
         * Create a bookmark
         * @description Create a bookmark for a post
         *
         *     Allows the authenticated user to bookmark a post for later reference.
         *     The post must exist and must not already be bookmarked by the user.
         */
        post: operations["CreateBookmark"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/bookmarks/{postId}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post?: never;
        /**
         * Delete a bookmark
         * @description Remove a bookmark
         *
         *     Deletes a bookmark for a specific post. Only the user who created
         *     the bookmark can remove it.
         */
        delete: operations["DeleteBookmark"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/auth/check-username": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Check username availability
         * @description Check if a username is available
         *
         *     Returns availability status for real-time validation during registration.
         *     Username must be between 3-30 characters to be considered valid.
         */
        get: operations["CheckUsername"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
}
export type webhooks = Record<string, never>;
export interface components {
    schemas: {
        /**
         * @description API response format for user profile
         * @example {
         *       "id": "123e4567-e89b-12d3-a456-426614174000",
         *       "username": "johndoe",
         *       "firstName": "John",
         *       "lastName": "Doe",
         *       "avatarUrl": "https://example.com/avatar.jpg",
         *       "bio": "Musician and producer",
         *       "location": "New York, NY",
         *       "userType": "musician",
         *       "onboardingCompleted": true,
         *       "createdAt": "2024-01-15T10:30:00Z"
         *     }
         */
        UserProfile: {
            id: string;
            username: string;
            firstName: string;
            lastName: string;
            avatarUrl: string | null;
            bio: string | null;
            aboutMe: string | null;
            /** Format: double */
            phoneCountryCode?: number;
            /** Format: double */
            phoneNumber?: number;
            /** Format: double */
            yearOfBirth?: number;
            location: string;
            userType: string;
            themeColor: string | null;
            spotifyPlaylistUrl: string | null;
            onboardingCompleted: boolean | null;
            createdAt: string | null;
            updatedAt: string | null;
        };
        /** @enum {string} */
        LookingForType: "connect" | "promote" | "find-band" | "find-services";
        /**
         * @description DTO for updating user profile
         *
         *     Used to update user profile information. All fields are optional - only
         *     provided fields will be updated. The user_id is automatically extracted
         *     from the authentication token.
         * @example {
         *       "firstName": "John",
         *       "lastName": "Doe",
         *       "bio": "Musician from New York",
         *       "location": "New York, NY",
         *       "themeColor": "#FF5733"
         *     }
         */
        UpdateProfileDto: {
            /**
             * @description Username (3-30 characters, only for initial profile creation)
             * @example johndoe
             */
            username?: string;
            /**
             * @description First name (1-50 characters)
             * @example John
             */
            firstName?: string;
            /**
             * @description Last name (1-50 characters)
             * @example Doe
             */
            lastName?: string;
            /**
             * @description Short bio (max 100 characters)
             * @example Musician from New York
             */
            bio?: string;
            /**
             * @description Detailed about me section (max 500 characters)
             * @example I'm a professional musician with 10 years of experience...
             */
            aboutMe?: string;
            /**
             * @description URL to user's avatar image
             * @example https://example.com/avatar.jpg
             */
            avatarUrl?: string;
            /**
             * @description User's location (1-100 characters)
             * @example New York, NY
             */
            location?: string;
            /**
             * @description Theme color in hex format
             * @example #FF5733
             */
            themeColor?: string;
            /**
             * @description URL to Spotify playlist
             * @example https://open.spotify.com/playlist/...
             */
            spotifyPlaylistUrl?: string;
            /**
             * Format: double
             * @description Phone country code (1-999)
             * @example 1
             */
            phoneCountryCode?: number;
            /**
             * Format: double
             * @description Phone number (4-15 digits, stored as bigint)
             * @example 1234567890
             */
            phoneNumber?: number;
            /**
             * Format: double
             * @description Year of birth
             * @example 1990
             */
            yearOfBirth?: number;
            /**
             * @description User type: "musician", "service_provider", or "other"
             * @example musician
             */
            userType?: string;
            /**
             * @description Whether user has completed onboarding
             * @example true
             */
            onboardingCompleted?: boolean;
            /**
             * @description Types of connections user is looking for
             * @example [
             *       "connect",
             *       "find-band"
             *     ]
             */
            lookingFor?: components["schemas"]["LookingForType"][];
        };
        /**
         * @description API response format for block status between two users
         * @example {
         *       "isBlocked": true,
         *       "direction": "blocker"
         *     }
         */
        BlockStatusResponse: {
            isBlocked: boolean;
            /** @enum {string|null} */
            direction: "blocker" | "blocked" | null;
        };
        /**
         * @description API response format for a blocked user
         * @example {
         *       "id": "user-123",
         *       "username": "johndoe",
         *       "firstName": "John",
         *       "lastName": "Doe",
         *       "avatarUrl": "https://example.com/avatar.jpg"
         *     }
         */
        BlockedUserResponse: {
            id: string;
            username: string;
            firstName: string;
            lastName: string;
            avatarUrl: string | null;
        };
        /**
         * @description API response format for user social media links
         * @example {
         *       "userId": "user-123",
         *       "instagram": "johndoe",
         *       "twitter": "@johndoe",
         *       "youtube": "johndoechannel",
         *       "soundcloud": null,
         *       "facebook": null,
         *       "tiktok": null,
         *       "bandcamp": null
         *     }
         */
        UserSocialMediaResponse: {
            userId: string;
            instagram: string | null;
            twitter: string | null;
            facebook: string | null;
            youtube: string | null;
            soundcloud: string | null;
            tiktok: string | null;
            bandcamp: string | null;
        };
        /** @description DTO for updating user social media links */
        UpdateSocialMediaDto: {
            instagram?: string | null;
            twitter?: string | null;
            facebook?: string | null;
            youtube?: string | null;
            soundcloud?: string | null;
            tiktok?: string | null;
            bandcamp?: string | null;
        };
        /**
         * @description API response format for user FAQ answer with question
         * @example {
         *       "id": "faq-123",
         *       "questionId": "q-456",
         *       "question": "What genres do you specialize in?",
         *       "answer": "I specialize in electronic and ambient music",
         *       "createdAt": "2024-01-20T15:30:00Z"
         *     }
         */
        UserFaqResponse: {
            id: string;
            questionId: string;
            question: string;
            answer: string;
            createdAt: string | null;
        };
        /** @description DTO for creating/updating user FAQ answer */
        UpsertFaqDto: {
            questionId: string;
            answer: string;
        };
        /**
         * @description API response format for user's "looking for" preferences
         * @example {
         *       "userId": "user-123",
         *       "lookingForValue": "connect"
         *     }
         */
        UserLookingForResponse: {
            userId: string;
            /** @enum {string} */
            lookingForValue: "connect" | "promote" | "find-band" | "find-services";
        };
        /**
         * @description API response format for FAQ question
         * @example {
         *       "id": "q-456",
         *       "question": "What genres do you specialize in?",
         *       "displayOrder": 1,
         *       "isActive": true
         *     }
         */
        FaqQuestionResponse: {
            id: string;
            question: string;
            /** Format: double */
            displayOrder: number;
            isActive: boolean;
        };
        /**
         * @description API response format for signed upload URL
         *
         *     Returns a temporary signed URL that allows direct client uploads to Supabase Storage.
         *     The client uses this URL to upload files directly, bypassing the backend.
         * @example {
         *       "signedUrl": "https://[project].supabase.co/storage/v1/object/sign/posts/user-123/file.jpg?...",
         *       "filePath": "posts/user-123/1234567890-abc123.jpg"
         *     }
         */
        SignedUrlResponse: {
            signedUrl: string;
            filePath: string;
        };
        /**
         * @description DTO for requesting a signed upload URL
         *
         *     Used to generate a temporary signed URL for direct client uploads to Supabase Storage.
         *     The client will use this signed URL to upload files directly, bypassing the backend.
         * @example {
         *       "fileName": "my-image.jpg",
         *       "fileType": "image/jpeg",
         *       "uploadType": "post"
         *     }
         */
        SignedUrlRequestDto: {
            /**
             * @description Original file name (used to determine file extension)
             * @example my-image.jpg
             */
            fileName: string;
            /**
             * @description MIME type of the file (used for validation)
             * @example image/jpeg
             */
            fileType: string;
            /**
             * @description Upload type: "post" for post media, "avatar" for profile pictures
             * @default post
             * @example post
             * @enum {string}
             */
            uploadType: "post" | "avatar";
        };
        /**
         * @description API response format for a service
         *     Represents a service offering (seeded data - no creation endpoint).
         *     Services can be: rehearsal_space, studio, recording, art, venue, teaching, or equipment_rental.
         *     provider_id is practically always null since there are no provider users.
         * @example {
         *       "id": "4f99a480-d388-47c2-86f5-efa0b8b164a0",
         *       "providerId": null,
         *       "providerName": "Lighthouse Music",
         *       "title": "Acoustic Band Room",
         *       "description": "Bright room with natural light suitable for rehearsals.",
         *       "mediaUrl": "https://example.com/media/acoustic-band-room.jpg",
         *       "location": "Roskilde, DK",
         *       "serviceType": "rehearsal_space",
         *       "createdAt": "2025-12-10T16:13:01.154276Z",
         *       "updatedAt": "2025-12-10T16:13:01.154276Z"
         *     }
         */
        ServiceResponse: {
            id: string;
            providerId: string | null;
            providerName: string | null;
            title: string;
            description: string;
            mediaUrl: string | null;
            location: string | null;
            /** @enum {string|null} */
            serviceType: "rehearsal_space" | "studio" | "recording" | "art" | "venue" | "teaching" | "equipment_rental" | null;
            createdAt: string | null;
            updatedAt: string | null;
        };
        /** @enum {string} */
        ServiceType: "rehearsal_space" | "studio" | "recording" | "art" | "venue" | "teaching" | "equipment_rental";
        /**
         * @description Search result for a user (from search_people)
         * @example {
         *       "type": "user",
         *       "id": "user-123",
         *       "username": "johndoe",
         *       "firstName": "John",
         *       "lastName": "Doe",
         *       "avatarUrl": "https://...",
         *       "bio": "Musician and producer",
         *       "location": "New York, NY",
         *       "genres": [
         *         "rock",
         *         "indie"
         *       ],
         *       "lookingFor": [
         *         "connect",
         *         "find-band"
         *       ],
         *       "isConnected": false,
         *       "relevance": 0.95
         *     }
         */
        UserSearchResult: {
            /** @enum {string} */
            type: "user";
            id: string;
            username: string;
            firstName: string;
            lastName: string;
            avatarUrl?: string | null;
            bio?: string | null;
            location?: string | null;
            genres?: unknown;
            lookingFor?: string[];
            isConnected: boolean;
            /** Format: double */
            relevance: number;
        };
        /**
         * @description Search result for a collaboration request (from search_collaborations)
         * @example {
         *       "type": "collaboration",
         *       "id": "post-123",
         *       "title": "Looking for Drummer",
         *       "description": "Rock band seeking experienced drummer",
         *       "authorId": "user-456",
         *       "authorUsername": "janedoe",
         *       "authorAvatarUrl": "https://...",
         *       "location": "Los Angeles, CA",
         *       "paidOpportunity": true,
         *       "genres": [
         *         "rock",
         *         "alternative"
         *       ],
         *       "createdAt": "2024-01-20T12:00:00Z",
         *       "relevance": 0.88
         *     }
         */
        CollaborationSearchResult: {
            /** @enum {string} */
            type: "collaboration";
            id: string;
            title: string;
            description: string;
            authorId: string;
            authorUsername: string;
            authorFirstName: string;
            authorAvatarUrl?: string | null;
            location?: string | null;
            paidOpportunity: boolean;
            genres?: unknown;
            createdAt: string;
            /** Format: double */
            relevance: number;
        };
        /**
         * @description Search result for services (from search_services)
         * @example {
         *       "type": "service",
         *       "id": "service-123",
         *       "title": "Mixing & Mastering",
         *       "description": "Professional audio mixing and mastering services",
         *       "serviceType": "mixing",
         *       "relevance": 0.85
         *     }
         */
        ServiceSearchResult: {
            /** @enum {string} */
            type: "service";
            id: string;
            title: string;
            description: string;
            serviceType: string | null;
            providerId: string | null;
            providerName: string | null;
            providerUsername: string | null;
            providerAvatarUrl: string | null;
            location: string | null;
            createdAt: string;
            /** Format: double */
            relevance: number;
        };
        /**
         * @description Search result for metadata/tags (from search_tags)
         * @example {
         *       "type": "tag",
         *       "id": "tag-123",
         *       "name": "indie-rock",
         *       "usageCount": 42,
         *       "relevance": 0.75
         *     }
         */
        TagSearchResult: {
            /** @enum {string} */
            type: "tag" | "genre" | "artist";
            id: string;
            name: string;
            /** Format: double */
            usageCount: number;
            /** Format: double */
            relevance: number;
        };
        /**
         * @description Search result for "For You" tab (from search_for_you)
         *     Polymorphic result that can be a user, collaboration, service, or tag
         * @example {
         *       "type": "for_you",
         *       "entityType": "user",
         *       "entityId": "user-123",
         *       "title": "John Doe",
         *       "subtitle": "Musician  New York, NY",
         *       "avatarUrl": "https://...",
         *       "matchReason": "Similar genres and location",
         *       "additionalInfo": {
         *         "genres": [
         *           "rock",
         *           "indie"
         *         ]
         *       },
         *       "relevance": 0.92
         *     }
         */
        ForYouSearchResult: {
            /** @enum {string} */
            type: "for_you";
            /** @enum {string} */
            entityType: "user" | "collaboration" | "service" | "tag";
            entityId: string;
            title: string;
            subtitle: string;
            avatarUrl?: string | null;
            matchReason: string;
            additionalInfo?: unknown;
            /** Format: double */
            relevance: number;
        };
        /** @description Union type for all search results */
        SearchResult: components["schemas"]["UserSearchResult"] | components["schemas"]["CollaborationSearchResult"] | components["schemas"]["ServiceSearchResult"] | components["schemas"]["TagSearchResult"] | components["schemas"]["ForYouSearchResult"];
        /** @description API response format for search results */
        SearchResponse: {
            results: components["schemas"]["SearchResult"][];
            /** Format: double */
            total?: number;
        };
        /**
         * @description API response format for a recent search entry
         * @example {
         *       "id": "search-123",
         *       "userId": "user-456",
         *       "searchQuery": "guitarist",
         *       "searchTab": "people",
         *       "entityType": "user",
         *       "entityId": "user-789",
         *       "createdAt": "2024-01-20T15:30:00Z"
         *     }
         */
        RecentSearch: {
            id: string;
            userId: string;
            searchQuery: string;
            /** @enum {string} */
            searchTab: "for_you" | "people" | "collaborations" | "services" | "tags";
            entityType?: string;
            entityId?: string;
            createdAt: string;
        };
        /**
         * @description DTO for saving a recent search
         *
         *     Used when a user performs a search to save it to their history
         * @example {
         *       "query": "guitarist",
         *       "tab": "people",
         *       "entityType": "user",
         *       "entityId": "123e4567-e89b-12d3-a456-426614174000"
         *     }
         */
        SaveRecentSearchDto: {
            /**
             * @description Search query string
             * @example guitarist
             */
            query: string;
            /**
             * @description Search tab where the search was performed
             * @example people
             * @enum {string}
             */
            tab: "for_you" | "people" | "collaborations" | "services" | "tags";
            /**
             * @description Optional entity type if user clicked through to a specific result
             * @example user
             */
            entityType?: string;
            /**
             * @description Optional entity ID if user clicked through to a specific result
             * @example 123e4567-e89b-12d3-a456-426614174000
             */
            entityId?: string;
        };
        /**
         * @description API response format for a user review
         *     Represents a 5-star rating and review text for a user
         * @example {
         *       "id": "review-123",
         *       "userId": "user-456",
         *       "reviewerId": "user-123",
         *       "rating": 5,
         *       "description": "Excellent collaborator, very professional!",
         *       "createdAt": "2024-01-20T15:30:00Z",
         *       "reviewer": {
         *         "id": "user-123",
         *         "username": "johndoe",
         *         "firstName": "John",
         *         "lastName": "Doe",
         *         "avatarUrl": "https://..."
         *       }
         *     }
         */
        ReviewResponse: {
            id: string;
            userId: string;
            reviewerId: string;
            /** Format: double */
            rating: number;
            description?: string | null;
            createdAt: string | null;
            reviewer?: {
                avatarUrl?: string | null;
                lastName?: string | null;
                firstName?: string | null;
                username: string;
                id: string;
            };
        };
        /** @description From T, pick a set of properties whose keys are in the union K */
        "Pick_ReviewInsert.Exclude_keyofReviewInsert.reviewer_id-or-user_id-or-created_at-or-id__": {
            description?: string;
            /** Format: double */
            rating: number;
        };
        /**
         * @description DTO for creating a review
         *
         *     Used when writing a review for a user.
         *     The reviewer_id is automatically extracted from the authentication token.
         * @example {
         *       "rating": 5,
         *       "description": "Great collaborator, very professional!"
         *     }
         */
        CreateReviewDto: {
            /**
             * @description Optional review description (max 500 characters)
             * @example Great collaborator, very professional!
             */
            description?: string | null;
            /**
             * Format: double
             * @description Rating from 1 to 5 stars
             * @example 5
             */
            rating: number;
        };
        /**
         * @description DTO for updating a review
         *
         *     Used when editing your own review.
         * @example {
         *       "rating": 4,
         *       "description": "Updated review description"
         *     }
         */
        UpdateReviewDto: {
            /**
             * Format: double
             * @description Updated rating from 1 to 5 stars
             * @example 4
             */
            rating?: number;
            /**
             * @description Updated review description (max 500 characters)
             * @example Updated review description
             */
            description?: string | null;
        };
        /**
         * @description API response format for a post with flattened relations
         *     This is the camelCase version of PostRow (database format)
         *     The mapper transforms PostRow (snake_case)  PostResponse (camelCase)
         */
        PostResponse: {
            id: string;
            /** @enum {string} */
            type: "note" | "request" | "story";
            title: string;
            description: string;
            authorId: string;
            createdAt: string | null;
            updatedAt: string | null;
            location: string | null;
            paidOpportunity: boolean | null;
            expiresAt: string | null;
            /** @enum {string} */
            status?: "active" | "resolved" | "archived";
            resolvedAt?: string | null;
            metadata?: {
                /** @enum {string} */
                type: "tag" | "genre" | "artist";
                name: string;
                id: string;
            }[];
            media?: {
                /** Format: double */
                displayOrder: number;
                /** @enum {string} */
                type: "image" | "video";
                thumbnailUrl?: string | null;
                url: string;
                id: string;
            }[];
            taggedUsers?: {
                avatarUrl?: string | null;
                lastName?: string | null;
                firstName?: string | null;
                username: string;
                id: string;
            }[];
            author?: {
                avatarUrl?: string | null;
                lastName?: string | null;
                firstName?: string | null;
                username: string;
                id: string;
            };
        };
        /** @enum {string} */
        PostType: "note" | "request" | "story";
        /**
         * @description DTO for media items attached to posts
         * @example {
         *       "url": "https://example.com/image.jpg",
         *       "thumbnailUrl": "https://example.com/thumb.jpg",
         *       "type": "image"
         *     }
         */
        MediaItemDto: {
            /**
             * @description URL to the media file
             * @example https://example.com/image.jpg
             */
            url: string;
            /**
             * @description Optional thumbnail URL for the media
             * @example https://example.com/thumb.jpg
             */
            thumbnailUrl?: string;
            /**
             * @description Media type: "image" or "video"
             * @example image
             */
            type: string;
        };
        /** @description From T, pick a set of properties whose keys are in the union K */
        "Pick_PostInsert.Exclude_keyofPostInsert.id-or-author_id-or-created_at-or-updated_at-or-search_vector__": {
            description: string;
            expires_at?: string;
            location?: string;
            paid_opportunity?: boolean;
            resolved_at?: string;
            status?: string;
            title: string;
            /** @enum {string} */
            type: "note" | "request" | "story";
        };
        /**
         * @description DTO for creating a new post
         *
         *     Used when creating a post (note, request, or story). The author_id is
         *     automatically extracted from the authentication token.
         *
         *     For "note" posts, you can include tags.
         *     For "request" posts, you can include genres and paidOpportunity flag.
         *     All post types can include media attachments and tagged users.
         * @example {
         *       "type": "note",
         *       "title": "My First Post",
         *       "description": "This is a detailed description of my post",
         *       "location": "New York, NY",
         *       "tags": [
         *         "music",
         *         "jazz"
         *       ],
         *       "media": [
         *         {
         *           "url": "https://example.com/image.jpg",
         *           "type": "image"
         *         }
         *       ]
         *     }
         */
        CreatePostBody: {
            /**
             * @description Post description (10-5000 characters)
             * @example I'm looking for an experienced drummer to join our band...
             */
            description: string;
            expires_at?: string;
            /**
             * @description Optional location where the post is relevant
             * @example New York, NY
             */
            location?: string | null;
            paid_opportunity?: boolean;
            resolved_at?: string;
            status?: string;
            /**
             * @description Post title (1-100 characters)
             * @example Looking for a drummer
             */
            title: string;
            /**
             * @description Post type: "note", "request", or "story"
             * @example note
             */
            type: components["schemas"]["PostType"];
            /**
             * @description Whether this is a paid opportunity (only for "request" type posts)
             * @example true
             */
            paidOpportunity?: boolean | null;
            /**
             * @description Optional expiration date/time (ISO 8601 format)
             * @example 2024-12-31T23:59:59Z
             */
            expiresAt?: string | null;
            /**
             * @description Tags for "note" type posts
             * @example [
             *       "music",
             *       "jazz",
             *       "performance"
             *     ]
             */
            tags?: string[];
            /**
             * @description Genres for "request" type posts
             * @example [
             *       "rock",
             *       "pop",
             *       "indie"
             *     ]
             */
            genres?: string[];
            /**
             * @description Array of user IDs to tag in the post
             * @example [
             *       "123e4567-e89b-12d3-a456-426614174000"
             *     ]
             */
            taggedUsers?: string[];
            /**
             * @description Media attachments (images or videos)
             * @example [
             *       {
             *         "url": "https://example.com/image.jpg",
             *         "type": "image"
             *       }
             *     ]
             */
            media?: components["schemas"]["MediaItemDto"][];
        };
        /** @description Generic paginated response wrapper */
        PaginatedResponse_PostResponse_: {
            data: components["schemas"]["PostResponse"][];
            pagination: {
                /** Format: double */
                total?: number;
                hasMore: boolean;
                nextCursor?: string;
            };
        };
        /**
         * @description API response format for a comment
         *     Represents a comment on a post with author information
         * @example {
         *       "id": "comment-123",
         *       "postId": "post-123",
         *       "authorId": "user-456",
         *       "content": "Great track! Love the production.",
         *       "createdAt": "2024-01-20T16:00:00Z",
         *       "updatedAt": "2024-01-20T16:00:00Z",
         *       "author": {
         *         "id": "user-456",
         *         "username": "janedoe",
         *         "firstName": "Jane",
         *         "lastName": "Doe",
         *         "avatarUrl": "https://..."
         *       }
         *     }
         */
        CommentResponse: {
            id: string;
            postId: string;
            authorId: string;
            content: string;
            createdAt: string | null;
            updatedAt: string | null;
            parentId?: string | null;
            replies?: components["schemas"]["CommentResponse"][];
            author?: {
                avatarUrl?: string | null;
                lastName?: string | null;
                firstName?: string | null;
                username: string;
                id: string;
            };
            /** Format: double */
            likesCount?: number;
            isLiked?: boolean;
        };
        /**
         * @description DTO for updating an existing post
         *
         *     All fields are optional - only provided fields will be updated.
         *     Only the post author can update their posts.
         * @example {
         *       "title": "Updated Title",
         *       "description": "Updated description text"
         *     }
         */
        UpdatePostBody: {
            /**
             * @description Updated post title (1-100 characters)
             * @example Updated Title
             */
            title?: string;
            /**
             * @description Updated post description (10-5000 characters)
             * @example Updated description text
             */
            description?: string;
            /**
             * @description Updated location
             * @example Los Angeles, CA
             */
            location?: string | null;
            /**
             * @description Whether this is a paid opportunity (only for "request" type posts)
             * @example true
             */
            paidOpportunity?: boolean | null;
        };
        /**
         * @description API response format for a notification
         *     Represents a notification with actor information
         */
        NotificationResponse: {
            id: string;
            recipientId: string;
            actorId?: string | null;
            type: string;
            entityType?: string | null;
            entityId?: string | null;
            title: string;
            body?: string | null;
            actionUrl?: string | null;
            isRead: boolean | null;
            isArchived: boolean | null;
            createdAt: string | null;
            readAt?: string | null;
            actor?: {
                avatarUrl?: string | null;
                lastName?: string | null;
                firstName?: string | null;
                username: string;
                id: string;
            };
        };
        /** @description Construct a type with a set of properties K of type T */
        "Record_like-or-comment-or-connection_request-or-connection_accepted-or-tagged_in_post-or-review-or-collaboration_request-or-message.NotificationResponse-Array_": {
            like: components["schemas"]["NotificationResponse"][];
            comment: components["schemas"]["NotificationResponse"][];
            connection_request: components["schemas"]["NotificationResponse"][];
            connection_accepted: components["schemas"]["NotificationResponse"][];
            tagged_in_post: components["schemas"]["NotificationResponse"][];
            review: components["schemas"]["NotificationResponse"][];
            collaboration_request: components["schemas"]["NotificationResponse"][];
            message: components["schemas"]["NotificationResponse"][];
        };
        /**
         * @description API response format for grouped notifications
         *     Returns notifications organized by type for easy filtering in the frontend
         *     Uses Record type to ensure all notification types are included
         */
        GroupedNotificationsResponse: components["schemas"]["Record_like-or-comment-or-connection_request-or-connection_accepted-or-tagged_in_post-or-review-or-collaboration_request-or-message.NotificationResponse-Array_"];
        /**
         * @description DTO for updating a notification
         *
         *     Used when marking a notification as read or unread.
         * @example {
         *       "isRead": true
         *     }
         */
        UpdateNotificationDto: {
            /**
             * @description Whether the notification is read
             * @example true
             */
            isRead: boolean;
        };
        /**
         * @description API response format for metadata item
         * @example {
         *       "id": "abc123",
         *       "type": "tag",
         *       "name": "indie-rock",
         *       "createdAt": "2024-01-15T10:30:00Z"
         *     }
         */
        MetadataItem: {
            id: string;
            /** @enum {string} */
            type: "tag" | "genre" | "artist";
            name: string;
            createdAt: string | null;
        };
        /**
         * @description API response format for metadata endpoint
         *     Returns all available tags, genres, and artists organized by type
         * @example {
         *       "tags": [
         *         {
         *           "id": "1",
         *           "type": "tag",
         *           "name": "indie",
         *           "createdAt": "2024-01-15T10:30:00Z"
         *         }
         *       ],
         *       "genres": [
         *         {
         *           "id": "2",
         *           "type": "genre",
         *           "name": "Rock",
         *           "createdAt": "2024-01-15T10:30:00Z"
         *         }
         *       ],
         *       "artists": [
         *         {
         *           "id": "3",
         *           "type": "artist",
         *           "name": "The Beatles",
         *           "createdAt": "2024-01-15T10:30:00Z"
         *         }
         *       ]
         *     }
         */
        MetadataResponse: {
            tags: components["schemas"]["MetadataItem"][];
            genres: components["schemas"]["MetadataItem"][];
            artists: components["schemas"]["MetadataItem"][];
        };
        /**
         * @description API response format for a message
         *     Represents a message in a conversation with sender info and optional reply
         */
        MessageResponse: {
            id: string;
            conversationId: string;
            senderId: string;
            content: string | null;
            mediaIds?: string[] | null;
            isEdited: boolean | null;
            editedAt?: string | null;
            isDeleted: boolean | null;
            deletedAt?: string | null;
            replyToMessageId?: string | null;
            createdAt: string | null;
            sender?: {
                avatarUrl?: string | null;
                lastName?: string | null;
                firstName?: string | null;
                username: string;
                id: string;
            };
            replyTo?: components["schemas"]["MessageResponse"] | null;
            readReceipts?: components["schemas"]["MessageReadReceiptResponse"][];
            media?: {
                type: string;
                thumbnailUrl?: string | null;
                url: string;
                id: string;
            }[];
        };
        /**
         * @description API response format for a message read receipt
         * @example {
         *       "messageId": "msg-789",
         *       "userId": "user-456",
         *       "readAt": "2024-01-20T16:05:00Z",
         *       "user": {
         *         "id": "user-456",
         *         "username": "janedoe",
         *         "firstName": "Jane",
         *         "lastName": "Doe",
         *         "avatarUrl": "https://..."
         *       }
         *     }
         */
        MessageReadReceiptResponse: {
            messageId: string;
            userId: string;
            readAt: string | null;
            user?: {
                avatarUrl?: string | null;
                lastName?: string | null;
                firstName?: string | null;
                username: string;
                id: string;
            };
        };
        /**
         * @description API response format for paginated messages
         *     Used by GET /messages/:conversationId endpoint
         */
        PaginatedMessagesResponse: {
            messages: components["schemas"]["MessageResponse"][];
            hasMore: boolean;
            nextCursor: string | null;
        };
        SendMessageDto: {
            conversation_id: string;
            content: string;
            media_ids?: string[];
            reply_to_message_id?: string | null;
        };
        EditMessageDto: {
            content: string;
        };
        MarkMessagesReadDto: {
            message_ids: string[];
        };
        /**
         * @description API response format for a post in the feed
         *     Extends PostResponse with engagement data and user interaction state
         */
        FeedPostResponse: {
            id: string;
            /** @enum {string} */
            type: "note" | "request" | "story";
            title: string;
            description: string;
            authorId: string;
            createdAt: string | null;
            updatedAt: string | null;
            location: string | null;
            paidOpportunity: boolean | null;
            expiresAt: string | null;
            /** @enum {string} */
            status?: "active" | "resolved" | "archived";
            resolvedAt?: string | null;
            metadata?: {
                /** @enum {string} */
                type: "tag" | "genre" | "artist";
                name: string;
                id: string;
            }[];
            media?: {
                /** Format: double */
                displayOrder: number;
                /** @enum {string} */
                type: "image" | "video";
                thumbnailUrl?: string | null;
                url: string;
                id: string;
            }[];
            taggedUsers?: {
                avatarUrl?: string | null;
                lastName?: string | null;
                firstName?: string | null;
                username: string;
                id: string;
            }[];
            author?: {
                avatarUrl?: string | null;
                lastName?: string | null;
                firstName?: string | null;
                username: string;
                id: string;
            };
            /** Format: double */
            likesCount?: number;
            /** Format: double */
            commentsCount?: number;
            /** Format: double */
            bookmarksCount?: number;
            hasLiked?: boolean;
            hasBookmarked?: boolean;
        };
        /** @description API response format for a conversation participant */
        ConversationParticipantResponse: {
            userId: string;
            conversationId: string;
            joinedAt: string | null;
            leftAt?: string | null;
            isAdmin: boolean | null;
            lastReadMessageId?: string | null;
            lastReadAt?: string | null;
            notificationsEnabled: boolean | null;
            isMuted: boolean | null;
            user?: {
                avatarUrl?: string | null;
                lastName?: string | null;
                firstName?: string | null;
                username: string;
                id: string;
            };
        };
        /**
         * @description API response format for a conversation
         *     Represents a direct message or group conversation
         */
        ConversationResponse: {
            id: string;
            /** @enum {string} */
            type: "direct" | "group";
            name?: string | null;
            avatarUrl?: string | null;
            createdBy: string;
            createdAt: string | null;
            updatedAt: string | null;
            lastMessageId?: string | null;
            lastMessagePreview?: string | null;
            lastMessageAt?: string | null;
            lastMessageSenderId?: string | null;
            /** Format: double */
            unreadCount: number;
            relatedPostId?: string | null;
            creator?: {
                avatarUrl?: string | null;
                lastName?: string | null;
                firstName?: string | null;
                username: string;
                id: string;
            };
            participants?: components["schemas"]["ConversationParticipantResponse"][];
        };
        /** @enum {string} */
        ConversationType: "direct" | "group";
        CreateConversationDto: {
            type: components["schemas"]["ConversationType"];
            name?: string | null;
            avatarUrl?: string | null;
            participantIds: string[];
            postId?: string | null;
        };
        UpdateConversationDto: {
            name?: string | null;
            avatarUrl?: string | null;
        };
        AddParticipantsDto: {
            participantIds: string[];
        };
        /**
         * @description Status of a connection request between two users
         * @enum {string}
         */
        ConnectionStatus: "pending" | "accepted" | "rejected";
        /**
         * @description API response format for a connection request
         *     Represents a connection request between two users with requester/recipient profiles
         */
        Connection: {
            id: string;
            requesterId: string;
            recipientId: string;
            status: components["schemas"]["ConnectionStatus"];
            createdAt: string | null;
            updatedAt: string | null;
            requester?: components["schemas"]["UserProfile"];
            recipient?: components["schemas"]["UserProfile"];
        };
        /**
         * @description DTO for creating a connection request
         *
         *     Used when sending a connection request to another user.
         *     The requester_id is automatically extracted from the authentication token.
         * @example {
         *       "recipientId": "a1b2c3d4-e5f6-7890-1234-567890abcdef"
         *     }
         */
        CreateConnectionRequestDto: {
            /**
             * @description The ID of the user to send the connection request to (UUID format)
             * @example a1b2c3d4-e5f6-7890-1234-567890abcdef
             */
            recipientId: string;
        };
        /**
         * @description DTO for updating a connection request status
         *
         *     Used when accepting or rejecting a connection request.
         *     Only the recipient can update the status.
         * @example {
         *       "status": "accepted"
         *     }
         */
        UpdateConnectionRequestDto: {
            /**
             * @description The new status for the connection request
             * @example accepted
             */
            status: components["schemas"]["ConnectionStatus"];
        };
        /** @description From T, pick a set of properties whose keys are in the union K */
        "Pick_CommentInsert.Exclude_keyofCommentInsert.author_id-or-created_at-or-updated_at-or-id-or-post_id-or-parent_id__": {
            content: string;
        };
        /** @description Construct a type with the properties of T except for those in type K. */
        "Omit_CommentInsert.author_id-or-created_at-or-updated_at-or-id-or-post_id-or-parent_id_": components["schemas"]["Pick_CommentInsert.Exclude_keyofCommentInsert.author_id-or-created_at-or-updated_at-or-id-or-post_id-or-parent_id__"];
        /**
         * @description DTO for creating a comment
         *
         *     Used when creating a comment on a post. The author_id is automatically
         *     extracted from the authentication token.
         * @example {
         *       "postId": "a1b2c3d4-e5f6-7890-1234-567890abcdef",
         *       "content": "Great post! Looking forward to collaborating."
         *     }
         */
        CreateCommentDto: {
            /**
             * @description The ID of the post to comment on (UUID format)
             * @example a1b2c3d4-e5f6-7890-1234-567890abcdef
             */
            postId: string;
            /**
             * @description The comment content (1-1000 characters)
             * @example Great post! Looking forward to collaborating.
             */
            content: string;
            /**
             * @description Optional parent comment ID for nested replies (UUID format)
             *     If provided, this comment will be a reply to the parent comment
             * @example a1b2c3d4-e5f6-7890-1234-567890abcdef
             */
            parentId?: string | null;
        };
        /**
         * @description DTO for updating a comment
         *
         *     Used when updating an existing comment. Only the content can be updated.
         * @example {
         *       "content": "Updated comment text"
         *     }
         */
        UpdateCommentDto: {
            /**
             * @description The updated comment content (1-1000 characters)
             * @example Updated comment text
             */
            content: string;
        };
        /**
         * @description API response format for a user collaboration
         *     Represents a past collaboration between two users
         * @example {
         *       "id": "collab-123",
         *       "userId": "user-123",
         *       "collaboratorId": "user-456",
         *       "description": "Worked together on album production",
         *       "createdAt": "2024-01-20T15:30:00Z",
         *       "collaborator": {
         *         "id": "user-456",
         *         "username": "janedoe",
         *         "firstName": "Jane",
         *         "lastName": "Doe",
         *         "avatarUrl": "https://..."
         *       }
         *     }
         */
        CollaborationResponse: {
            id: string;
            userId: string;
            collaboratorId: string;
            description?: string | null;
            createdAt: string | null;
            collaborator?: {
                avatarUrl?: string | null;
                lastName?: string | null;
                firstName?: string | null;
                username: string;
                id: string;
            };
        };
        /**
         * @description DTO for creating a collaboration
         *
         *     Represents a past collaboration between the authenticated user and another user.
         *     The description is optional and limited to 200 characters.
         * @example {
         *       "collaboratorId": "a1b2c3d4-e5f6-7890-1234-567890abcdef",
         *       "description": "Worked together on a jazz album in 2023"
         *     }
         */
        CreateCollaborationDto: {
            /**
             * @description The ID of the user you collaborated with (UUID format)
             * @example a1b2c3d4-e5f6-7890-1234-567890abcdef
             */
            collaboratorId: string;
            /**
             * @description Optional description of the collaboration (max 200 characters)
             * @example Worked together on a jazz album in 2023
             */
            description?: string | null;
        };
        /**
         * @description API response format for a bookmark
         *     Includes the bookmark details and optional post information with author
         * @example {
         *       "postId": "post-123",
         *       "userId": "user-456",
         *       "createdAt": "2024-01-20T15:30:00Z",
         *       "post": {
         *         "id": "post-123",
         *         "title": "New Song Release",
         *         "description": "Check it out!",
         *         "type": "note",
         *         "location": null,
         *         "createdAt": "2024-01-20T12:00:00Z",
         *         "author": {
         *           "id": "user-123",
         *           "username": "johndoe",
         *           "firstName": "John",
         *           "lastName": "Doe",
         *           "avatarUrl": "https://..."
         *         }
         *       }
         *     }
         */
        BookmarkResponse: {
            postId: string;
            userId: string;
            createdAt: string | null;
            post?: {
                author?: {
                    avatarUrl: string | null;
                    lastName: string;
                    firstName: string;
                    username: string;
                    id: string;
                };
                createdAt: string | null;
                location: string | null;
                type: string;
                description: string;
                title: string;
                id: string;
            };
        };
        /**
         * @description DTO for creating a bookmark
         *
         *     Used when a user wants to bookmark a post for later reference.
         *     The user_id is automatically extracted from the authentication token.
         * @example {
         *       "postId": "123e4567-e89b-12d3-a456-426614174000"
         *     }
         */
        CreateBookmarkDto: {
            /**
             * @description The UUID of the post to bookmark
             * @example 123e4567-e89b-12d3-a456-426614174000
             */
            postId: string;
        };
    };
    responses: never;
    parameters: never;
    requestBodies: never;
    headers: never;
    pathItems: never;
}
export type $defs = Record<string, never>;
export interface operations {
    GetUser: {
        parameters: {
            query?: never;
            header?: {
                Authorization?: string;
            };
            path: {
                /** @description The username of the user to retrieve */
                username: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description User profile (public or private based on authentication) */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["UserProfile"];
                };
            };
        };
    };
    UpdateProfile: {
        parameters: {
            query?: never;
            header?: {
                Authorization?: string;
            };
            path: {
                /** @description The username of the profile to update (must match authenticated user) */
                username: string;
            };
            cookie?: never;
        };
        /** @description The profile fields to update (all optional) */
        requestBody: {
            content: {
                "application/json": components["schemas"]["UpdateProfileDto"];
            };
        };
        responses: {
            /** @description Updated user profile */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["UserProfile"];
                };
            };
        };
    };
    BlockUser: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The ID of the user to block */
                userId: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success message */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        message: string;
                    };
                };
            };
        };
    };
    UnblockUser: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The ID of the user to unblock */
                userId: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success message */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        message: string;
                    };
                };
            };
        };
    };
    GetBlockStatus: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The ID of the target user to check */
                userId: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Block status information */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["BlockStatusResponse"];
                };
            };
        };
    };
    GetBlockedUsers: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Array of blocked users */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data: components["schemas"]["BlockedUserResponse"][];
                    };
                };
            };
        };
    };
    GetUserSocialMedia: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The username of the user */
                username: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description User's social media links */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["UserSocialMediaResponse"];
                };
            };
        };
    };
    UpdateUserSocialMedia: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The username (must match authenticated user) */
                username: string;
            };
            cookie?: never;
        };
        /** @description Social media links to update */
        requestBody: {
            content: {
                "application/json": components["schemas"]["UpdateSocialMediaDto"];
            };
        };
        responses: {
            /** @description Updated social media links */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["UserSocialMediaResponse"];
                };
            };
        };
    };
    GetUserFaq: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The username of the user */
                username: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description User's FAQ answers with questions */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["UserFaqResponse"][];
                };
            };
        };
    };
    UpsertUserFaq: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The username (must match authenticated user) */
                username: string;
            };
            cookie?: never;
        };
        /** @description Question ID and answer */
        requestBody: {
            content: {
                "application/json": components["schemas"]["UpsertFaqDto"];
            };
        };
        responses: {
            /** @description The created/updated FAQ answer */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["UserFaqResponse"];
                };
            };
        };
    };
    DeleteUserFaq: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The username (must match authenticated user) */
                username: string;
                /** @description The question ID to delete answer for */
                questionId: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description No content */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    GetUserLookingFor: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The username of the user */
                username: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description User's looking for preferences */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["UserLookingForResponse"][];
                };
            };
        };
    };
    GetAllFaqQuestions: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description List of all active FAQ questions */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["FaqQuestionResponse"][];
                };
            };
        };
    };
    GenerateSignedUploadUrl: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Request body containing fileName, fileType, and optional uploadType */
        requestBody: {
            content: {
                "application/json": components["schemas"]["SignedUrlRequestDto"];
            };
        };
        responses: {
            /** @description Signed URL and file path for direct client upload */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["SignedUrlResponse"];
                };
            };
        };
    };
    DeleteMedia: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The UUID of the media to delete */
                mediaId: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description No content */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    GetServices: {
        parameters: {
            query?: {
                /** @description Filter by service type */
                serviceType?: components["schemas"]["ServiceType"];
                /** @description Filter by location (case-insensitive partial match) */
                location?: string;
                /** @description Maximum number of services to return (default: 100) */
                limit?: number;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Array of services */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data: components["schemas"]["ServiceResponse"][];
                    };
                };
            };
        };
    };
    Search: {
        parameters: {
            query?: {
                /** @description Search query string */
                q?: string;
                /** @description Search tab: "for_you", "people", "collaborations", "services", or "tags" (default: "for_you") */
                tab?: "for_you" | "people" | "collaborations" | "services" | "tags";
                /** @description Filter by location */
                location?: string;
                /** @description Filter by genres (array) */
                genres?: string[];
                /** @description Filter by looking for types (for people tab) */
                lookingFor?: string[];
                /** @description Filter for paid opportunities only (for collaborations tab) */
                paidOnly?: boolean;
                /** @description Maximum number of results (1-100, default: 20) */
                limit?: number;
                /** @description Offset for pagination (default: 0) */
                offset?: number;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Search results based on the selected tab */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["SearchResponse"];
                };
            };
        };
    };
    GetRecentSearches: {
        parameters: {
            query?: {
                /** @description Maximum number of results (default: 15) */
                limit?: number;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Array of recent searches */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["RecentSearch"][];
                };
            };
        };
    };
    SaveRecentSearch: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Search details to save */
        requestBody: {
            content: {
                "application/json": components["schemas"]["SaveRecentSearchDto"];
            };
        };
        responses: {
            /** @description No content */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    ClearAllRecentSearches: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description No content */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    DeleteRecentSearch: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The ID of the recent search to delete */
                id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description No content */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    GetUserReviews: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The username of the user to retrieve reviews for */
                username: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Array of reviews with reviewer details */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ReviewResponse"][];
                };
            };
        };
    };
    CreateReview: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The username of the user being reviewed */
                username: string;
            };
            cookie?: never;
        };
        /** @description Review data including rating (1-5) and optional description */
        requestBody: {
            content: {
                "application/json": components["schemas"]["CreateReviewDto"];
            };
        };
        responses: {
            /** @description The newly created review */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ReviewResponse"];
                };
            };
        };
    };
    GetReview: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The UUID of the review to retrieve */
                reviewId: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The review with reviewer details */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ReviewResponse"];
                };
            };
        };
    };
    DeleteReview: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The UUID of the review to delete */
                reviewId: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description No content */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    UpdateReview: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The UUID of the review to update */
                reviewId: string;
            };
            cookie?: never;
        };
        /** @description Updated review data (rating and/or description) */
        requestBody: {
            content: {
                "application/json": components["schemas"]["UpdateReviewDto"];
            };
        };
        responses: {
            /** @description The updated review */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ReviewResponse"];
                };
            };
        };
    };
    ListPosts: {
        parameters: {
            query?: {
                /** @description Filter by post type: "note", "request", or "story" */
                type?: "note" | "request" | "story";
                /** @description Filter by author user ID */
                authorId?: string;
                /** @description Cursor for pagination (ISO timestamp) */
                cursor?: string;
                /** @description Maximum number of posts to return (1-100, default: 20) */
                limit?: number;
                /** @description Whether to include engagement data (requires auth) */
                includeEngagement?: boolean;
                /** @description Whether to include media in the response */
                includeMedia?: boolean;
                /** @description Filter by genre IDs (array) */
                genreIds?: string[];
                /** @description Filter by tag names (array) */
                tags?: string[];
                /** @description Filter by location */
                location?: string;
                /** @description Filter for paid opportunities only */
                paidOnly?: boolean;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Paginated list of posts */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["PaginatedResponse_PostResponse_"];
                };
            };
        };
    };
    CreatePost: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description The post data including type, title, description, and optional fields */
        requestBody: {
            content: {
                "application/json": components["schemas"]["CreatePostBody"];
            };
        };
        responses: {
            /** @description The created post with all related data (metadata, media, tagged users, author) */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["PostResponse"];
                };
            };
        };
    };
    GetPost: {
        parameters: {
            query?: {
                /** @description Whether to include comments in the response */
                includeComments?: boolean;
                /** @description Maximum number of comments to return (1-100, default: 50) */
                commentsLimit?: number;
            };
            header?: never;
            path: {
                /** @description The UUID of the post to retrieve */
                id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The post with all related data, optional comments, and optional engagement */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["PostResponse"] & {
                        hasBookmarked?: boolean;
                        hasLiked?: boolean;
                        /** Format: double */
                        bookmarksCount?: number;
                        /** Format: double */
                        commentsCount?: number;
                        /** Format: double */
                        likesCount?: number;
                        comments?: components["schemas"]["CommentResponse"][];
                    };
                };
            };
        };
    };
    UpdatePost: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The UUID of the post to update */
                id: string;
            };
            cookie?: never;
        };
        /** @description The fields to update */
        requestBody: {
            content: {
                "application/json": components["schemas"]["UpdatePostBody"];
            };
        };
        responses: {
            /** @description The updated post */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["PostResponse"];
                };
            };
        };
    };
    DeletePost: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The UUID of the post to delete */
                id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description No content */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    ResolvePost: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The UUID of the post to resolve */
                id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The updated post with resolved status */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["PostResponse"];
                };
            };
        };
    };
    LikePost: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The UUID of the post to like */
                id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description No content */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    UnlikePost: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The UUID of the post to unlike */
                id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description No content */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    GetPostRespondents: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The UUID of the post */
                id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description List of users who started a chat on this post */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        avatarUrl?: string | null;
                        lastName?: string | null;
                        firstName?: string | null;
                        username: string;
                        id: string;
                    }[];
                };
            };
        };
    };
    GetAllPostRespondents: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description List of unique users who started chats on the user's posts */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        avatarUrl?: string | null;
                        lastName?: string | null;
                        firstName?: string | null;
                        username: string;
                        id: string;
                    }[];
                };
            };
        };
    };
    GetNotifications: {
        parameters: {
            query?: {
                /** @description Filter by notification type (ignored if grouped=true) */
                type?: string;
                /** @description If true, only return unread notifications */
                unreadOnly?: boolean;
                /** @description Cursor for pagination (ISO timestamp) */
                cursor?: string;
                /** @description Maximum number of notifications to return (1-100, default: 50) */
                limit?: number;
                /** @description If true, returns notifications grouped by type as an object */
                grouped?: boolean;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Notifications with pagination cursor (flat array or grouped by type) */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        nextCursor?: string;
                        notifications: components["schemas"]["NotificationResponse"][];
                    } | {
                        nextCursor?: string;
                        notifications: components["schemas"]["GroupedNotificationsResponse"];
                    };
                };
            };
        };
    };
    GetNotification: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The UUID of the notification to retrieve */
                notificationId: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The notification with actor information */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["NotificationResponse"];
                };
            };
        };
    };
    DeleteNotification: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The UUID of the notification to delete */
                notificationId: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description No content */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    UpdateNotification: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The UUID of the notification to update */
                notificationId: string;
            };
            cookie?: never;
        };
        /** @description Update data including isRead status */
        requestBody: {
            content: {
                "application/json": components["schemas"]["UpdateNotificationDto"];
            };
        };
        responses: {
            /** @description The updated notification */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["NotificationResponse"];
                };
            };
        };
    };
    GetUnreadCount: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Object containing the count of unread notifications */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /** Format: double */
                        count: number;
                    };
                };
            };
        };
    };
    GetMetadata: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Metadata grouped by type (tags, genres, artists) */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["MetadataResponse"];
                };
            };
        };
    };
    GetMessages: {
        parameters: {
            query?: {
                limit?: number;
                before_message_id?: string;
            };
            header?: never;
            path: {
                conversationId: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Ok */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["PaginatedMessagesResponse"];
                };
            };
        };
    };
    SendMessage: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["SendMessageDto"];
            };
        };
        responses: {
            /** @description Ok */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["MessageResponse"];
                };
            };
        };
    };
    EditMessage: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                messageId: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["EditMessageDto"];
            };
        };
        responses: {
            /** @description Ok */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        status: string;
                        sender_id: string;
                        reply_to_message_id: string;
                        media_ids: string[];
                        is_edited: boolean;
                        is_deleted: boolean;
                        id: string;
                        edited_at: string;
                        deleted_at: string;
                        created_at: string;
                        conversation_id: string;
                        content: string;
                    };
                };
            };
        };
    };
    DeleteMessage: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                messageId: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description No content */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    MarkAsRead: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["MarkMessagesReadDto"];
            };
        };
        responses: {
            /** @description Ok */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        success: boolean;
                    };
                };
            };
        };
    };
    SetTyping: {
        parameters: {
            query?: {
                isTyping?: boolean;
            };
            header?: never;
            path: {
                conversationId: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description No content */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    GetFeed: {
        parameters: {
            query?: {
                /** @description The feed component to fetch (default: "posts") */
                component?: "posts" | "recommendations" | "stories";
                /** @description Cursor for pagination (ISO timestamp) */
                cursor?: string;
                /** @description Maximum number of items to return (1-50, default: 20) */
                limit?: number;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Feed posts with pagination cursor, or recommendations array */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        nextCursor?: string;
                        posts: components["schemas"]["FeedPostResponse"][];
                    } | {
                        recommendations: components["schemas"]["FeedPostResponse"][];
                    } | {
                        stories: unknown[];
                    };
                };
            };
        };
    };
    GetConversations: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Ok */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ConversationResponse"][];
                };
            };
        };
    };
    CreateConversation: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["CreateConversationDto"];
            };
        };
        responses: {
            /** @description Ok */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ConversationResponse"];
                };
            };
        };
    };
    GetUnreadCount: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Ok */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /** Format: double */
                        count: number;
                    };
                };
            };
        };
    };
    GetConversation: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                conversationId: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Ok */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ConversationResponse"];
                };
            };
        };
    };
    UpdateConversation: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                conversationId: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["UpdateConversationDto"];
            };
        };
        responses: {
            /** @description Ok */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ConversationResponse"];
                };
            };
        };
    };
    DeleteConversation: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                conversationId: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description No content */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    AddParticipants: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                conversationId: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["AddParticipantsDto"];
            };
        };
        responses: {
            /** @description Ok */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ConversationResponse"];
                };
            };
        };
    };
    RemoveParticipant: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                conversationId: string;
                userId: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description No content */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    GetConnectionRequests: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Array of connection requests (sent and received) */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Connection"][];
                };
            };
        };
    };
    CreateConnectionRequest: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Connection request data including recipient ID */
        requestBody: {
            content: {
                "application/json": components["schemas"]["CreateConnectionRequestDto"];
            };
        };
        responses: {
            /** @description The created connection request */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Connection"];
                };
            };
        };
    };
    GetSentConnectionRequests: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The UUID of the user to retrieve sent requests for */
                userId: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Array of connection requests sent by the user */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Connection"][];
                };
            };
        };
    };
    GetReceivedConnectionRequests: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The UUID of the user to retrieve received requests for */
                userId: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Array of connection requests received by the user */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Connection"][];
                };
            };
        };
    };
    GetConnectionStatus: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The UUID of the target user */
                targetUserId: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The connection if it exists, null otherwise */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Connection"] | null;
                };
            };
        };
    };
    GetUserAcceptedConnections: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The UUID of the user to retrieve accepted connections for */
                userId: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Array of accepted connections for the user */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Connection"][];
                };
            };
        };
    };
    UpdateConnectionRequest: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The UUID of the connection request to update */
                requestId: string;
            };
            cookie?: never;
        };
        /** @description Updated status (accepted or rejected) */
        requestBody: {
            content: {
                "application/json": components["schemas"]["UpdateConnectionRequestDto"];
            };
        };
        responses: {
            /** @description The updated connection request */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Connection"];
                };
            };
        };
    };
    DeleteConnectionRequest: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The UUID of the connection request to delete */
                requestId: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description No content */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    GetPostComments: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The UUID of the post to retrieve comments for */
                postId: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Array of comments with author details and like data */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["CommentResponse"][];
                };
            };
        };
    };
    GetUserComments: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The UUID of the user to retrieve comments for */
                userId: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Array of comments with author details */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["CommentResponse"][];
                };
            };
        };
    };
    CreateComment: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Comment data including post ID and content */
        requestBody: {
            content: {
                "application/json": components["schemas"]["CreateCommentDto"];
            };
        };
        responses: {
            /** @description The created comment with author details */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["CommentResponse"];
                };
            };
        };
    };
    UpdateComment: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The UUID of the comment to update */
                commentId: string;
            };
            cookie?: never;
        };
        /** @description Updated comment content */
        requestBody: {
            content: {
                "application/json": components["schemas"]["UpdateCommentDto"];
            };
        };
        responses: {
            /** @description The updated comment */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["CommentResponse"];
                };
            };
        };
    };
    DeleteComment: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The UUID of the comment to delete */
                commentId: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description No content */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    LikeComment: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The UUID of the comment to like */
                commentId: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description No content */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    UnlikeComment: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The UUID of the comment to unlike */
                commentId: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description No content */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    GetCollaborations: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Array of collaborations with collaborator details */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["CollaborationResponse"][];
                };
            };
        };
    };
    CreateCollaboration: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Collaboration data including collaborator ID and optional description */
        requestBody: {
            content: {
                "application/json": components["schemas"]["CreateCollaborationDto"];
            };
        };
        responses: {
            /** @description The created collaboration */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["CollaborationResponse"];
                };
            };
        };
    };
    GetUserCollaborations: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The UUID of the user to retrieve collaborations for */
                userId: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Array of collaborations with collaborator details */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["CollaborationResponse"][];
                };
            };
        };
    };
    DeleteCollaboration: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The UUID of the collaboration to delete */
                collaborationId: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description No content */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    GetBookmarks: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Array of bookmarks with post details */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["BookmarkResponse"][];
                };
            };
        };
    };
    CreateBookmark: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description The bookmark data containing the post ID to bookmark */
        requestBody: {
            content: {
                "application/json": components["schemas"]["CreateBookmarkDto"];
            };
        };
        responses: {
            /** @description The created bookmark */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["BookmarkResponse"];
                };
            };
        };
    };
    DeleteBookmark: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The UUID of the post to unbookmark */
                postId: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description No content */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    CheckUsername: {
        parameters: {
            query: {
                /** @description Username to check for availability */
                username: string;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Object containing available boolean */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        available: boolean;
                    };
                };
            };
        };
    };
}
