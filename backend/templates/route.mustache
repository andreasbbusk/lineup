// @ts-nocheck
/* tslint:disable */
/* eslint-disable */
// WARNING: This file was auto-generated with tsoa. Please do not modify it. Re-run tsoa to re-generate this file: https://github.com/lukeautry/tsoa
import type { TsoaRoute } from '@tsoa/runtime';
import {  fetchMiddlewares, ExpressTemplateService } from '@tsoa/runtime';
{{#each controllers}}
// WARNING: This file was auto-generated with tsoa. Please do not modify it. Re-run tsoa to re-generate this file: https://github.com/lukeautry/tsoa
import { {{name}} } from '{{modulePath}}';
{{/each}}
import { expressAuthentication } from './../middleware/authentication';
// @ts-ignore - no great way to install types from subpackage
import type { Request as ExRequest, Response as ExResponse, RequestHandler, Router } from 'express';


const expressAuthenticationRecasted = expressAuthentication as (req: ExRequest, securityName: string, scopes?: string[], res?: ExResponse) => Promise<any>;

function authenticateMiddleware(security: TsoaRoute.Security[]): RequestHandler {
    return async (req: ExRequest, res: ExResponse, next: any) => {
        try {
            for (const securityGroup of security) {
                // Handle both array and object security groups
                if (Array.isArray(securityGroup)) {
                    // If it's an array, iterate over elements (each element is an object with security names)
                    for (const securityObj of securityGroup) {
                        for (const securityName of Object.keys(securityObj)) {
                            await expressAuthenticationRecasted(req, securityName, securityObj[securityName], res);
                        }
                    }
                } else {
                    // If it's an object, iterate over keys directly
                    for (const securityName of Object.keys(securityGroup)) {
                        await expressAuthenticationRecasted(req, securityName, securityGroup[securityName], res);
                    }
                }
            }
            next();
        } catch (err) {
            next(err);
        }
    };
}

// WARNING: This file was auto-generated with tsoa. Please do not modify it. Re-run tsoa to re-generate this file: https://github.com/lukeautry/tsoa

const models: TsoaRoute.Models = {
    {{#each models}}
    "{{@key}}": {{{json this}}},
    {{/each}}
};

const templateService = new ExpressTemplateService(models, {
    noImplicitAdditionalProperties: 'throw-on-extras',
});

export function RegisterRoutes(app: Router) {

    // ###########################################################################################################
    //  NOTE: If you do not see routes for all of your controllers in this file, then you might not have informed tsoa of where to look
    //      Please look into the "controllerPathGlobs" config option described in the readme: https://github.com/lukeautry/tsoa
    // ###########################################################################################################

    {{#each controllers}}
    {{#each actions}}
        // WARNING: This file was auto-generated with tsoa. Please do not modify it. Re-run tsoa to re-generate this file: https://github.com/lukeautry/tsoa
        const args{{../name}}_{{name}}: Record<string, TsoaRoute.ParameterSchema> = {
            {{#each parameters}}
                {{name}}: {{{json this}}},
            {{/each}}
        };
        app.{{method}}('{{fullPath}}',
            {{#if security}}
            authenticateMiddleware([{{{json security}}}]),
            {{/if}}
            ...(fetchMiddlewares<RequestHandler>({{../name}})),
            ...(fetchMiddlewares<RequestHandler>({{../name}}.prototype.{{name}})),

            async function {{../name}}_{{name}}(request: ExRequest, response: ExResponse, next: any) {

            // WARNING: This file was auto-generated with tsoa. Please do not modify it. Re-run tsoa to re-generate this file: https://github.com/lukeautry/tsoa

            let validatedArgs: any[] = [];
            try {
                validatedArgs = templateService.getValidatedArgs({ args: args{{../name}}_{{name}}, request, response });

                const controller = new {{../name}}();

              await templateService.apiHandler({
                methodName: '{{name}}',
                controller,
                response,
                next,
                validatedArgs,
                successStatus: {{successStatus}},
              });
            } catch (err) {
                return next(err);
            }
        });
    {{/each}}
    {{/each}}
}

